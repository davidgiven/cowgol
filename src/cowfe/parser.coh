# Important: this is not a recursive descent parser (because Cowgol doesn't
# support recursion). It reads one statement at a time, using an explicit stack
# to store data, and Dijksta's Shunting Yard Algorithm for parsing recursive
# structures like types or expressions. Make sure not to call any routine
# reentrantly!

sub Parse() is
    const PARSE_STACK_SIZE := 128;
    var stack: [void][PARSE_STACK_SIZE];
    var sp: @indexof stack;
    var opstack: uint8[PARSE_STACK_SIZE];
    var opsp: @indexof opstack;

    var exit_label: LabelRef := nil;
    var true_label: LabelRef := nil;
    var false_label: LabelRef := nil;
    var false_generated: uint8 := 0;
    var break_label: LabelRef := 0;
    var continue_label: LabelRef := 0;

    const UNARY_FLAG := 0x80;

    sub SyntaxError(token: uint8) is
        StartError();
        print("syntax error: unexpected ");
        PrintTokenName(token);
        EndError();
    end sub;

    sub BadStructureError(token: uint8) is
        SimpleError("mismatched structure");
    end sub;

    sub Push(p: [void]) is
        stack[sp] := p;
        sp := sp + 1;
    end sub;

    sub Pop(): (val: [void]) is
        if sp == 0 then
            SimpleError("opstack underflow");
        end if;
        
        sp := sp - 1;
        val := stack[sp];
    end sub;

    sub PushSymbol(p: [Symbol]) is
        Push(p as [void]);
    end sub;

    sub PushType(t: [Type]) is
        Push(t as [void]);
    end sub;

    sub PushNode(n: [Node]) is
        Push(n as [void]);
    end sub;

    sub PushLabelRef(ref: LabelRef) is
        Push(ref as intptr as [void]);
    end sub;

    sub PushInt(i: uint8) is
        Push(i as intptr as [void]);
    end sub;

    sub PopType(): (t: [Type]) is
        t := Pop() as [Type];
    end sub;

    sub PopNode(): (n: [Node]) is
        n := Pop() as [Node];
    end sub;

    sub PopLabelRef(): (ref: LabelRef) is
        ref := Pop() as intptr as LabelRef;
    end sub;

    sub PopInt(): (n: uint8) is
        n := Pop() as intptr as uint8;
    end sub;

    sub PushIfData() is
        PushLabelRef(exit_label);
        PushLabelRef(true_label);
        PushLabelRef(false_label);
        PushInt(false_generated);
        PushInt(IF);
    end sub;

    sub PopIfData() is
        if PopInt() != IF then
            BadStructureError(IF);
        end if;

        false_generated := PopInt();
        false_label := PopLabelRef();
        true_label := PopLabelRef();
        exit_label := PopLabelRef();
    end sub;

    sub PushLoopData() is
        PushLabelRef(break_label);
        PushLabelRef(continue_label);
        PushInt(LOOP);
    end sub;

    sub PopLoopData() is
        if PopInt() != LOOP then
            BadStructureError(LOOP);
        end if;

        continue_label := PopLabelRef();
        break_label := PopLabelRef();
    end sub;

    sub CheckStructure(t: uint8) is
        if (sp == 0) or (stack[sp-1] as intptr as uint8 != t) then
            BadStructureError(t);
        end if;
    end sub;

    sub PushOp(op: uint8) is
        opstack[opsp] := op;
        opsp := opsp + 1;
    end sub;

    sub PopOp(): (op: uint8) is
        if opsp == 0 then
            SimpleError("opstack underflow");
        end if;

        opsp := opsp - 1;
        op := opstack[opsp];
    end sub;

    sub RequireToken(t: uint8) is
        if token != t then
            StartError();
            print("expected token ");
            PrintTokenName(t);
            print(", but got ");
            PrintTokenName(token);
            EndError();
        end if;
        LexerGetToken();
    end sub;

    sub GrabTokenBuffer(): (news: string) is
        news := InternalStrDup(&token_buffer[0]);
    end sub;

    sub _check_for_identifier() is
        if token != ID then
            SimpleError("expected identifier");
        end if;
    end sub;

    sub ParseNewSymbol(): (sym: [Symbol]) is
        _check_for_identifier();
        sym := AddSymbol(0 as [Namespace], GrabTokenBuffer());
        LexerGetToken();
    end sub;

    sub ParseExistingSymbol(): (sym: [Symbol]) is
        _check_for_identifier();
        sym := LookupSymbol(0 as [Namespace], &token_buffer[0]);
        if sym == (0 as [Symbol]) then
            StartError();
            print("symbol '");
            print(&token_buffer[0]);
            print("' not found");
            EndError();
        end if;
        LexerGetToken();
    end sub;

    sub ParseNewOrExistingSymbol(): (sym: [Symbol]) is
        _check_for_identifier();
        var name := GrabTokenBuffer();
        sym := LookupSymbol(0 as [Namespace], name);
        if sym == (0 as [Symbol]) then
            sym := AddSymbol(0 as [Namespace], name);
        else
            Free(name);
        end if;
        LexerGetToken();
    end sub;

    sub ParseType(): (type: [Type]) is
        var startsp := sp;
        sub popops() is
            while opsp != 0 loop
                opsp := opsp - 1;
                case opstack[opsp] is
                    when OPENSQ:
                        return;
                end case;
            end loop;
        end sub;

        sub parse() is
            loop
                # Terms and prefix operators.

                case token is
                    when OPENSQ:
                        opstack[opsp] := OPENSQ;
                        opsp := opsp + 1;
                        continue;
                    
                    when ID:
                        print("push id\n");
                        var sym := ParseNewOrExistingSymbol();
                        if sym.kind == 0 then
                            # Create a partial type.
                            type := AllocNewType();
                            type.kind := TYPE_PARTIAL;

                            sym.kind := TYPE;
                            sym.typedata := type;
                            type.symbol := sym;
                        else
                            # This type already exists.
                            type := sym.typedata;
                        end if;
                        if sym.kind != TYPE then
                            StartError();
                            print("expected ");
                            print(sym.name);
                            print(" to be a type");
                            EndError();
                        end if;
                        PushType(type);
                        # fall through to postfix section

                    when else:
                        StartError();
                        print("invalid token ");
                        PrintTokenName(token);
                        print(" in type expression term");
                        EndError();
                end case;

                loop
                    # Postfix.

                    case token is
                        when COMMA: return;
                        when ASSIGN: return;
                        when SEMICOLON: return;

                        when CLOSESQ:
                            popops();
                            PushType(MakePointerType(PopType()));
                            LexerGetToken();

                        when else:
                            StartError();
                            print("invalid token ");
                            PrintTokenName(token);
                            print(" in type expression postfix operator");
                            EndError();
                    end case;
                end loop;
            end loop;
        end sub;

        parse();
        type := PopType();
        if sp != startsp then
            SimpleError("unterminated expression");
        end if;
    end sub;

	sub Negate(node: [Node]) is
		node.beq.negated := node.beq.negated ^ 1;
	end sub;
 
	sub ConditionalEq(lhs: [Node], rhs: [Node], negated: uint8): (result: [Node]) is
		CondSimple(lhs, rhs);
		var truelabel := AllocLabel();
		var falselabel := AllocLabel();
		var w := NodeWidth(lhs);

		result := MidBeq(w, lhs, rhs, truelabel, falselabel, 0, negated);
	end sub;

	sub ConditionalLt(lhs: [Node], rhs: [Node], negated: uint8): (result: [Node]) is
		CondSimple(lhs, rhs);
		var truelabel := AllocLabel();
		var falselabel := AllocLabel();
		var w := NodeWidth(lhs);

		if IsSNum(lhs.type) != 0 then
			result := MidBlts(w, lhs, rhs, truelabel, falselabel, 0, negated);
		else
			result := MidBltu(w, lhs, rhs, truelabel, falselabel, 0, negated);
		end if;
	end sub;

    sub ParseExpression(): (node: [Node]) is
        var startsp := sp;
        var startopsp := opsp;

        sub precedenceof(op: uint8): (p: uint8) is
            if (op & UNARY_FLAG) != 0 then
                p := token_flags[op] >> 4;
            else
                p := token_flags[op] & 0x0f;
            end if;
        end sub;

        sub applyop() is
            var op := PopOp();
            var lhs: [Node];
            var rhs: [Node];

            print("apply ");
            print_i8(op);
            print(": ");
            PrintTokenName(op);
            print_nl();

            case op is
                when OPENPAREN:
                    # infix OPENPAREN is function application
                    # do nothing

                when OPENPAREN|UNARY_FLAG:
                    # unary OPENPAREN is grouping
                    # do nothing
                    
                when PLUS:
                    rhs := PopNode();
                    lhs := PopNode();
                    PushNode(ExprAdd(lhs, rhs));
                    
                when PLUS|UNARY_FLAG:
                    # do nothing

                when MINUS:
                    rhs := PopNode();
                    lhs := PopNode();
                    PushNode(ExprSub(lhs, rhs));
                    
                when MINUS|UNARY_FLAG:
                    lhs := PopNode();
                    PushNode(Expr1Simple(MIDCODE_NEG0, lhs));
                    
                when STAR:
                    rhs := PopNode();
                    lhs := PopNode();
                    PushNode(Expr2Simple(MIDCODE_MUL0, MIDCODE_MUL0, lhs, rhs));
                    
                when SLASH:
                    rhs := PopNode();
                    lhs := PopNode();
                    PushNode(Expr2Simple(MIDCODE_DIVS0, MIDCODE_DIVU0, lhs, rhs));
                    
                when PERCENT:
                    rhs := PopNode();
                    lhs := PopNode();
                    PushNode(Expr2Simple(MIDCODE_REMS0, MIDCODE_REMU0, lhs, rhs));
                    
                when UNARY_FLAG|TILDE:
                    lhs := PopNode();
                    PushNode(Expr1Simple(MIDCODE_NOT0, lhs));

                when CARET:
                    rhs := PopNode();
                    lhs := PopNode();
                    PushNode(Expr2Simple(MIDCODE_EOR0, MIDCODE_EOR0, lhs, rhs));
                    
                when AMPERSAND:
                    rhs := PopNode();
                    lhs := PopNode();
                    PushNode(Expr2Simple(MIDCODE_AND0, MIDCODE_AND0, lhs, rhs));
                    
                when UNARY_FLAG|AMPERSAND:
                    lhs := UndoLValue(PopNode());
                    if lhs.op == MIDCODE_ADDRESS then
                        var sym := lhs.address.sym;
                        if IsScalar(sym.vardata.type) != 0 then
                            SimpleError("you cannot take the address of scalar variables");
                        end if;
                    end if;

                when PIPE:
                    rhs := PopNode();
                    lhs := PopNode();
                    PushNode(Expr2Simple(MIDCODE_OR0, MIDCODE_OR0, lhs, rhs));
                    
                when LSHIFT:
                    rhs := PopNode();
                    lhs := PopNode();
                    PushNode(ExprShift(MIDCODE_LSHIFT0, MIDCODE_LSHIFT0, lhs, rhs));
                    
                when RSHIFT:
                    rhs := PopNode();
                    lhs := PopNode();
                    PushNode(ExprShift(MIDCODE_RSHIFTS0, MIDCODE_RSHIFTU0, lhs, rhs));

                when NOT:
                    lhs := PopNode();
                    Negate(lhs);
                    PushNode(lhs);

                when AND:
                    rhs := PopNode();
                    lhs := PopNode();
                    PushNode(MidBand(lhs, rhs, 0, 0, 0, 0));

                when OR:
                    rhs := PopNode();
                    lhs := PopNode();
                    PushNode(MidBor(lhs, rhs, 0, 0, 0, 0));

                when EQOP:
                    rhs := PopNode();
                    lhs := PopNode();
                    PushNode(ConditionalEq(lhs, rhs, 0));

                when NEOP:
                    rhs := PopNode();
                    lhs := PopNode();
                    PushNode(ConditionalEq(lhs, rhs, 1));

                when LTOP:
                    rhs := PopNode();
                    lhs := PopNode();
                    PushNode(ConditionalLt(lhs, rhs, 0));

                when GEOP:
                    rhs := PopNode();
                    lhs := PopNode();
                    PushNode(ConditionalLt(lhs, rhs, 0));

                when GTOP:
                    rhs := PopNode();
                    lhs := PopNode();
                    PushNode(ConditionalLt(rhs, lhs, 0));

                when LEOP:
                    rhs := PopNode();
                    lhs := PopNode();
                    PushNode(ConditionalLt(rhs, lhs, 1));
                
                when COMMA:
                    rhs := PopNode();
                    lhs := PopNode();
                    PushNode(MidPair(rhs, lhs));
                    
                when else:
                    StartError();
                    print("unhandled op ");
                    if (opstack[opsp] & UNARY_FLAG) != 0 then
                        print("unary ");
                    end if;
                    PrintTokenName(opstack[opsp] & 0x7f);
                    EndError();
            end case;
        end sub;

        sub applyops(p: uint8) is
            while opsp != 0 loop
                var topopp := precedenceof(opstack[opsp-1]);
                if topopp > p then
                    break;
                end if;

                applyop();
            end loop;
        end sub;

        sub popops() is
            while opsp != startopsp loop
                applyop();
            end loop;
        end sub;
        
        sub pushop(op: uint8) is
            print("push ");
            print_i8(op);
            print(": ");
            PrintTokenName(op);
            print_nl();

            applyops(precedenceof(op));
            PushOp(op);
        end sub;

        sub parse() is
            var f: uint8;
            var sym: [Symbol];
            var node: [Node];

            loop
                # Terms and prefix operators.
                    
                f := 0;
                if token < @sizeof token_flags then
                    f := token_flags[token];
                end if;

                case token is
                    when COMMA: return;
                    when ASSIGN: return;
                    when SEMICOLON: return;

                    when OPENPAREN:
                        PushOp(OPENPAREN);
                        LexerGetToken();
                        continue;
                    
                    when NUMBER:
                        PushNode(MidConstant(token_value));
                        LexerGetToken();

                    when ID:
                        sym := ParseExistingSymbol();

                        sub not_a_value() is
                            StartError();
                            print(sym.name);
                            print(" is not a value");
                            EndError();
                        end sub;

                        case sym.kind is
                            when CONST:
                                node := MidConstant(sym.constant);

                            when VAR:
                                node := MidAddress(sym, 0);
                                node.type := MakePointerType(sym.vardata.type);
                                node := MakeLValue(node);

                            when TYPE:
                                # Subroutine instances are passed around as their type, even if it
                                # does not *really* make sense. Every type must have a symbol, so
                                # by using the type as a subroutine literal, we save on having to
                                # create an extra symbol for it.
                                if sym.typedata.kind == TYPE_SUBROUTINE then
                                    node := MidSubref(sym.typedata.subrtype.subr);
                                    node.type := sym.typedata.subrtype.subr.intfsubr.type;
                                else
                                    not_a_value();
                                end if;

                            when else:
                                not_a_value();
                        end case;
                        PushNode(node);

                    when else:
                        if (f & 0xf0) != 0 then
                            pushop(UNARY_FLAG | token);
                            LexerGetToken();
                            continue; # next token is another term
                        else
                            StartError();
                            print("invalid token ");
                            PrintTokenName(token);
                            print(" in expression");
                            EndError();
                        end if;
                end case;

                loop
                    f := 0;
                    if token < @sizeof token_flags then
                        f := token_flags[token];
                    end if;

                    # Postfix.

                    case token is
                        when CLOSEPAREN:
                            popops();
                            LexerGetToken();

                        when else:
                            if (f & 0x0f) != 0 then
                                pushop(token);
                                LexerGetToken();
                                break; # next token is a term
                            else
                                return;
                            end if;
                    end case;
                end loop;
            end loop;
        end sub;

        parse();
        popops();
        node := PopNode();
        if sp != startsp then
            StartError();
            print("syntax error: unterminated expression at ");
            PrintTokenName(token);
            EndError();
        end if;
    end sub;

    sub ParseVar() is
        LexerGetToken();
        var sym := ParseNewSymbol();
        var type: [Type] := 0 as [Type];
        if token == COLON then
            LexerGetToken();
            type := ParseType();
        end if;

        var value: [Node] := (0 as [Node]);
        if token == ASSIGN then
            LexerGetToken();
            value := ParseExpression();
            if type == (0 as [Type]) then
                type := value.type;
                if type == (0 as [Type]) then
                    SimpleError("types cannot be inferred for numeric constants");
                end if;
                if IsScalar(type) == 0 then
                    SimpleError("you can only assign scalar values");
                end if;
            end if;
        end if;

        if type == (0 as [Type]) then
            SimpleError("type inference can't be used with a value to infer from");
        end if;

        InitVariable(current_subr, sym, type);

        if value != (0 as [Node]) then
            CheckExpressionType(value, sym.vardata.type);
            var w := value.type.width as uint8;
            Generate(MidStore(w, value, MidDeref(w, MidAddress(sym, 0))));
        end if;

        RequireToken(SEMICOLON);
    end sub;

    sub ParseExpressionStatement() is
        var lvalue: [Node] := ParseExpression();
        case token is
            when SEMICOLON:
                # Bare expressions must be void procedure calls.

            when ASSIGN:
                # Either a simple or a multi assignment.

                RequireToken(ASSIGN);
                var rvalue: [Node] := ParseExpression();
                
                var type := lvalue.type;
                var address := UndoLValue(lvalue);
                CheckExpressionType(rvalue, type);
                var w := type.width as uint8;
                Generate(MidStore(w, rvalue, MidDeref(w, address)));

            when else:
                SyntaxError(token);
        end case;
        RequireToken(SEMICOLON);
    end sub;

    sub ParseIf() is
        LexerGetToken();

        PushIfData();
        true_label := AllocLabel();
        false_label := AllocLabel();
        exit_label := AllocLabel();
        false_generated := 0;

        var cond := ParseExpression();
        cond.beq.truelabel := true_label;
        cond.beq.falselabel := false_label;
        cond.beq.fallthrough := true_label;
        GenerateConditional(cond);

        RequireToken(THEN);
    end sub;

    sub CheckElseIsLast() is
        if false_generated != 0 then
            SimpleError("'else' must be last");
        end if;
    end sub;
    
    sub ParseElseif() is
        LexerGetToken();

        CheckStructure(IF);
        CheckElseIsLast();

        Generate(MidJump(exit_label));
        Generate(MidLabel(false_label));

        true_label := AllocLabel();
        false_label := AllocLabel();
        # false_generated is 0
        
        var cond := ParseExpression();
        cond.beq.truelabel := true_label;
        cond.beq.falselabel := false_label;
        cond.beq.fallthrough := true_label;
        GenerateConditional(cond);

        RequireToken(THEN);
    end sub;

    sub ParseElse() is
        LexerGetToken();

        CheckStructure(IF);
        CheckElseIsLast();

        Generate(MidJump(exit_label));
        Generate(MidLabel(false_label));
        false_generated := 1;
    end sub;
        
    sub ParseEndIf() is
        LexerGetToken();

        CheckStructure(IF);
        if false_generated == 0 then
            Generate(MidLabel(false_label));
        end if;
        Generate(MidLabel(exit_label));
        PopIfData();
    
        RequireToken(SEMICOLON);
    end sub;

    sub ParseLoop() is
        LexerGetToken();
        PushLoopData();

        break_label := AllocLabel();
        continue_label := AllocLabel();
        Generate(MidLabel(continue_label));
    end sub;
        
    sub ParseWhile() is
        ParseLoop();
        
        var cond := ParseExpression();
        cond.beq.truelabel := AllocLabel();
        cond.beq.falselabel := break_label;
        cond.beq.fallthrough := cond.beq.truelabel;
        GenerateConditional(cond);

        RequireToken(LOOP);
    end sub;

    sub ParseEndLoop() is
        LexerGetToken();
        Generate(MidJump(continue_label));
        Generate(MidLabel(break_label));

        PopLoopData();
        RequireToken(SEMICOLON);
    end sub;

    sub ParseContinue() is
        LexerGetToken();
        if continue_label == 0 then
            SimpleError("nowhere to continue to");
        end if;
        Generate(MidJump(continue_label));
        RequireToken(SEMICOLON);
    end sub;
    
    sub ParseBreak() is
        LexerGetToken();
        if break_label == 0 then
            SimpleError("nowhere to break to");
        end if;
        Generate(MidJump(break_label));
        RequireToken(SEMICOLON);
    end sub;

    sp := 0;
    opsp := 0;

    while token != EOF loop
        case token is
            when VAR:      ParseVar();
            when IF:       ParseIf();
            when ELSE:     ParseElse();
            when ELSEIF:   ParseElseif();
            when WHILE:    ParseWhile();
            when LOOP:     ParseLoop();
            when BREAK:    ParseBreak();
            when CONTINUE: ParseContinue();

            when END:
                LexerGetToken();
                case token is
                    when IF:   ParseEndIf();
                    when LOOP: ParseEndLoop();

                    when else:
                        SyntaxError(token);
                end case;

            when else:
                ParseExpressionStatement();
        end case;
    end loop;
end sub;
