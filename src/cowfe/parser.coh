# Important: this is not a recursive descent parser (because Cowgol doesn't
# support recursion). It reads one statement at a time, using an explicit stack
# to store data, and Dijksta's Shunting Yard Algorithm for parsing recursive
# structures like types or expressions. Make sure not to call any routine
# reentrantly!

sub Parse() is
    const PARSE_STACK_SIZE := 128;
    var stack: [void][PARSE_STACK_SIZE];
    var sp: @indexof stack;
    var opstack: uint8[PARSE_STACK_SIZE];
    var opsp: @indexof opstack;

    var exit_label: LabelRef := nil;
    var true_label: LabelRef := nil;
    var false_label: LabelRef := nil;
    var false_generated: uint8 := 0;
    var break_label: LabelRef := 0;
    var continue_label: LabelRef := 0;

    var type_mode: uint8;

    const UNARY_FLAG := 0x80;

    sub SyntaxError(token: uint8) is
        StartError();
        print("syntax error: unexpected ");
        PrintTokenName(token);
        EndError();
    end sub;

    sub BadStructureError(token: uint8) is
        SimpleError("mismatched structure");
    end sub;

    sub Push(p: [void]) is
        stack[sp] := p;
        sp := sp + 1;
    end sub;

    sub Pop(): (val: [void]) is
        if sp == 0 then
            SimpleError("opstack underflow");
        end if;
        
        sp := sp - 1;
        val := stack[sp];
    end sub;

    sub PushSymbol(p: [Symbol]) is
        Push(p as [void]);
    end sub;

    sub PushType(t: [Type]) is
        Push(t as [void]);
    end sub;

    sub PushNode(n: [Node]) is
        Push(n as [void]);
    end sub;

    sub PushLabelRef(ref: LabelRef) is
        Push(ref as intptr as [void]);
    end sub;

    sub PushInt(i: uint8) is
        Push(i as intptr as [void]);
    end sub;

    sub PopType(): (t: [Type]) is
        t := Pop() as [Type];
    end sub;

    sub PopNode(): (n: [Node]) is
        n := Pop() as [Node];
    end sub;

    sub PopLabelRef(): (ref: LabelRef) is
        ref := Pop() as intptr as LabelRef;
    end sub;

    sub PopInt(): (n: uint8) is
        n := Pop() as intptr as uint8;
    end sub;

    sub PushIfData() is
        PushLabelRef(exit_label);
        PushLabelRef(true_label);
        PushLabelRef(false_label);
        PushInt(false_generated);
        PushInt(IF);
    end sub;

    sub PopIfData() is
        if PopInt() != IF then
            BadStructureError(IF);
        end if;

        false_generated := PopInt();
        false_label := PopLabelRef();
        true_label := PopLabelRef();
        exit_label := PopLabelRef();
    end sub;

    sub PushLoopData() is
        PushLabelRef(break_label);
        PushLabelRef(continue_label);
        PushInt(LOOP);
    end sub;

    sub PopLoopData() is
        if PopInt() != LOOP then
            BadStructureError(LOOP);
        end if;

        continue_label := PopLabelRef();
        break_label := PopLabelRef();
    end sub;

    sub CheckStructure(t: uint8) is
        if (sp == 0) or (stack[sp-1] as intptr as uint8 != t) then
            BadStructureError(t);
        end if;
    end sub;

    sub PrintOpStack() is
        var i: uint8 := 0;
        print("[");
        while i != opsp loop
            if i != 0 then
                print_char(' ');
            end if;

            var op := opstack[i];
            if (op & UNARY_FLAG) != 0 then
                print("U+");
            end if;
            PrintTokenName(op & 0x7f);
            i := i + 1;
        end loop;
        print("]\n");
    end sub;

    sub PushOp(op: uint8) is
        print("pushop: ");
        print_i8(op);
        print_nl();

        opstack[opsp] := op;
        opsp := opsp + 1;
    
        PrintOpStack();
    end sub;

    sub PopOp(): (op: uint8) is
        if opsp == 0 then
            SimpleError("opstack underflow");
        end if;

        opsp := opsp - 1;
        op := opstack[opsp];

        print("popop: ");
        print_i8(op);
        print_nl();
    end sub;

    sub RequireToken(t: uint8) is
        if token != t then
            StartError();
            print("expected token ");
            PrintTokenName(t);
            print(", but got ");
            PrintTokenName(token);
            EndError();
        end if;
        LexerGetToken();
    end sub;

    sub GrabTokenBuffer(): (news: string) is
        news := InternalStrDup(&token_buffer[0]);
    end sub;

    sub _check_for_identifier() is
        if token != ID then
            SimpleError("expected identifier");
        end if;
    end sub;

    sub ParseNewSymbol(): (sym: [Symbol]) is
        _check_for_identifier();
        sym := AddSymbol(0 as [Namespace], GrabTokenBuffer());
        LexerGetToken();
    end sub;

    sub ParseExistingSymbol(): (sym: [Symbol]) is
        _check_for_identifier();
        sym := LookupSymbol(0 as [Namespace], &token_buffer[0]);
        if sym == (0 as [Symbol]) then
            StartError();
            print("symbol '");
            print(&token_buffer[0]);
            print("' not found");
            EndError();
        end if;
        LexerGetToken();
    end sub;

    sub ParseNewOrExistingSymbol(): (sym: [Symbol]) is
        _check_for_identifier();
        var name := GrabTokenBuffer();
        sym := LookupSymbol(0 as [Namespace], name);
        if sym == (0 as [Symbol]) then
            sym := AddSymbol(0 as [Namespace], name);
        else
            Free(name);
        end if;
        LexerGetToken();
    end sub;

    sub ToConstant(node: [Node]): (value: int32) is
        if node.op != MIDCODE_CONSTANT then
            SimpleError("non-constant value provided");
        end if;
        value := node.constant.value;
    end sub;
    
	sub Negate(node: [Node]) is
		node.beq.negated := node.beq.negated ^ 1;
	end sub;
 
	sub ConditionalEq(lhs: [Node], rhs: [Node], negated: uint8): (result: [Node]) is
		CondSimple(lhs, rhs);
		var truelabel := AllocLabel();
		var falselabel := AllocLabel();
		var w := NodeWidth(lhs);

		result := MidBeq(w, lhs, rhs, truelabel, falselabel, 0, negated);
	end sub;

	sub ConditionalLt(lhs: [Node], rhs: [Node], negated: uint8): (result: [Node]) is
		CondSimple(lhs, rhs);
		var truelabel := AllocLabel();
		var falselabel := AllocLabel();
		var w := NodeWidth(lhs);

		if IsSNum(lhs.type) != 0 then
			result := MidBlts(w, lhs, rhs, truelabel, falselabel, 0, negated);
		else
			result := MidBltu(w, lhs, rhs, truelabel, falselabel, 0, negated);
		end if;
	end sub;

    sub ParseRaw() is
        var startsp := sp;
        var startopsp := opsp;

        sub peekop(): (op: uint8) is
            if opsp == startopsp then
                SimpleError("unterminated expression");
            end if;
            op := opstack[opsp-1];
        end sub;

        sub precedenceof(op: uint8): (p: uint8) is
            if (op & UNARY_FLAG) != 0 then
                p := token_flags[op] >> 4;
            else
                p := token_flags[op] & 0x0f;
            end if;
        end sub;

        sub applyvalueop() is
            var type: [Type];
            var op := PopOp();

            print("applyvalue ");
            if (op & UNARY_FLAG) != 0 then
                print("unary ");
            end if;
            print_i8(op & 0x7f);
            print(": ");
            PrintTokenName(op);
            print_nl();

            var rhs: [Node];
            if (op & UNARY_FLAG) == 0 then
                # Binary
                rhs := PopNode();
            end if;
            var lhs := PopNode();

            case op is
                when OPENPAREN:
                    # infix OPENPAREN is function application
                    # do nothing

                when OPENPAREN|UNARY_FLAG:
                    # unary OPENPAREN is grouping
                    # do nothing
                    
                when PLUS:
                    lhs := ExprAdd(lhs, rhs);
                    
                when PLUS|UNARY_FLAG:
                    # do nothing

                when MINUS:
                    lhs := ExprSub(lhs, rhs);
                    
                when MINUS|UNARY_FLAG:
                    lhs := Expr1Simple(MIDCODE_NEG0, lhs);
                    
                when STAR:
                    lhs := Expr2Simple(MIDCODE_MUL0, MIDCODE_MUL0, lhs, rhs);
                    
                when SLASH:
                    lhs := Expr2Simple(MIDCODE_DIVS0, MIDCODE_DIVU0, lhs, rhs);
                    
                when PERCENT:
                    lhs := Expr2Simple(MIDCODE_REMS0, MIDCODE_REMU0, lhs, rhs);
                    
                when UNARY_FLAG|TILDE:
                    lhs := Expr1Simple(MIDCODE_NOT0, lhs);

                when CARET:
                    lhs := Expr2Simple(MIDCODE_EOR0, MIDCODE_EOR0, lhs, rhs);
                    
                when AMPERSAND:
                    lhs := Expr2Simple(MIDCODE_AND0, MIDCODE_AND0, lhs, rhs);
                    
                when UNARY_FLAG|AMPERSAND:
                    lhs := UndoLValue(lhs);
                    if lhs.op == MIDCODE_ADDRESS then
                        var sym := lhs.address.sym;
                        if IsScalar(sym.vardata.type) != 0 then
                            SimpleError("you cannot take the address of scalar variables");
                        end if;
                    end if;

                when PIPE:
                    lhs := Expr2Simple(MIDCODE_OR0, MIDCODE_OR0, lhs, rhs);
                    
                when LSHIFT:
                    lhs := ExprShift(MIDCODE_LSHIFT0, MIDCODE_LSHIFT0, lhs, rhs);
                    
                when RSHIFT:
                    lhs := ExprShift(MIDCODE_RSHIFTS0, MIDCODE_RSHIFTU0, lhs, rhs);

                when NOT:
                    Negate(lhs);

                when AND:
                    lhs := MidBand(lhs, rhs, 0, 0, 0, 0);

                when OR:
                    lhs := MidBor(lhs, rhs, 0, 0, 0, 0);

                when EQOP:
                    lhs := ConditionalEq(lhs, rhs, 0);

                when NEOP:
                    lhs := ConditionalEq(lhs, rhs, 1);

                when LTOP:
                    lhs := ConditionalLt(lhs, rhs, 0);

                when GEOP:
                    lhs := ConditionalLt(lhs, rhs, 0);

                when GTOP:
                    lhs := ConditionalLt(rhs, lhs, 0);

                when LEOP:
                    lhs := ConditionalLt(rhs, lhs, 1);
                
                when COMMA:
                    lhs := MidPair(rhs, lhs);
                    
                when OPENSQ:
                    type := lhs.type;
                    lhs := MaybeUndoLValue(lhs);

                    if IsArray(type) == 0 then
                        StartError();
                        print("you can only index an array, not a ");
                        print(type.symbol.name);
                        EndError();
                    end if;

                    CheckExpressionType(rhs, type.arraytype.indextype);
                    if IsNum(rhs.type) == 0 then
                            SimpleError("array indices must be numbers");
                    end if;

                    var elementtype := type.arraytype.element;
                    var w := intptr_type.width as uint8;

                    var displacement := MidC2Op(MIDCODE_MUL0, w,
                        MidCCast(intptr_type.width as uint8, rhs, 0),
                        MidConstant(elementtype.stride as int32));
                    displacement.type := intptr_type;

                    var adjustedaddress := MidC2Op(MIDCODE_ADD0, w, lhs, displacement);
                    adjustedaddress.type := MakePointerType(elementtype);
                    lhs := MakeLValue(adjustedaddress);

                when OPENSQ_TYPE:
                    # Bit of a hack here --- the LHS is really a type.
                    var length := ToConstant(rhs);
                    type := MakeArrayType(lhs as [Type], length as uint16);
                    PushType(type);
                    type_mode := 1;
                    return;

                when else:
                    StartError();
                    print("unhandled value op ");
                    if (opstack[opsp] & UNARY_FLAG) != 0 then
                        print("unary ");
                    end if;
                    PrintTokenName(opstack[opsp] & 0x7f);
                    EndError();
            end case;
        
            PushNode(lhs);
        end sub;

        sub applytypeop() is
            var op := PopOp();

            print("applytype ");
            if (op & UNARY_FLAG) != 0 then
                print("unary ");
            end if;
            print_i8(op & 0x7f);
            print(": ");
            PrintTokenName(op);
            print_nl();

            case op is
                    
                when else:
                    StartError();
                    print("unhandled type op ");
                    if (opstack[opsp] & UNARY_FLAG) != 0 then
                        print("unary ");
                    end if;
                    PrintTokenName(opstack[opsp] & 0x7f);
                    EndError();
            end case;
        end sub;

        sub applyop() is
            PrintOpStack();
            if type_mode == 0 then
                applyvalueop();
            else
                applytypeop();
            end if;
        end sub;

        sub applyops(p: uint8) is
            while opsp != 0 loop
                var topopp := precedenceof(opstack[opsp-1]);
                if topopp < p then
                    break;
                end if;

                applyop();
            end loop;
        end sub;

        sub pushop(op: uint8) is
            print("push ");
            print_i8(op);
            print(": ");
            PrintTokenName(op);
            print_nl();

            applyops(precedenceof(op));
            PushOp(op);
        end sub;

        sub bad_context(kind: string) is
            StartError();
            print("can't use ");
            PrintTokenName(token);
            print(" in a ");
            print(kind);
            print(" context");
            EndError();
        end sub;

        sub not_allowed_in_type() is
            if type_mode != 0 then
                bad_context("type");
            end if;
        end sub;

        sub parse() is
            var f: uint8;
            var sym: [Symbol];
            var node: [Node];
            var op: uint8;

            loop
                # Terms and prefix operators.
                    
                f := 0;
                if token < @sizeof token_flags then
                    f := token_flags[token];
                end if;

                print("seen ");
                PrintTokenName(token & 0x7f);
                print("; type_mode=");
                print_i8(type_mode);
                print_nl();

                print("prefix\n");
                case token is
                    when COMMA: return;
                    when ASSIGN: return;
                    when SEMICOLON: return;

                    when OPENPAREN:
                        not_allowed_in_type();
                        PushOp(OPENPAREN|UNARY_FLAG);
                        LexerGetToken();
                        continue;
                    
                    when NUMBER:
                        not_allowed_in_type();
                        print("push const ");
                        print_i32(token_value as uint32);
                        print_nl();
                        PushNode(MidConstant(token_value));
                        LexerGetToken();

                    when ID:
                        sym := ParseExistingSymbol();

                        sub not_a(kind: string) is
                            StartError();
                            print(sym.name);
                            print(" is not a ");
                            print(kind);
                            EndError();
                        end sub;

                        if type_mode == 0 then
                            # Parse as expression.
                            case sym.kind is
                                when CONST:
                                    node := MidConstant(sym.constant);

                                when VAR:
                                    node := MidAddress(sym, 0);
                                    node.type := MakePointerType(sym.vardata.type);
                                    node := MakeLValue(node);

                                when TYPE:
                                    # Subroutine instances are passed around as their type, even if it
                                    # does not *really* make sense. Every type must have a symbol, so
                                    # by using the type as a subroutine literal, we save on having to
                                    # create an extra symbol for it.
                                    if sym.typedata.kind == TYPE_SUBROUTINE then
                                        node := MidSubref(sym.typedata.subrtype.subr);
                                        node.type := sym.typedata.subrtype.subr.intfsubr.type;
                                    else
                                        not_a("value");
                                    end if;

                                when else:
                                    not_a("value");
                            end case;
                            PushNode(node);
                        else
                            # Parse as type.
                            if sym.kind == 0 then
                                var type := AllocNewType();
                                type.kind := TYPE_PARTIAL;

                                sym.kind := TYPE;
                                sym.typedata := type;
                                type.symbol := sym;
                            end if;
                            if sym.kind != TYPE then
                                not_a("type");
                            end if;
                            PushType(sym.typedata);
                        end if;

                    when else:
                        if (f & 0xf0) != 0 then
                            pushop(UNARY_FLAG | token);
                            LexerGetToken();
                            continue; # next token is another term
                        else
                            StartError();
                            print("invalid token ");
                            PrintTokenName(token);
                            print(" in expression");
                            EndError();
                        end if;
                end case;

                loop
                    f := 0;
                    if token < @sizeof token_flags then
                        f := token_flags[token];
                    end if;

                    # Infix.

                    print("infix\n");
                    case token is
                        when CLOSEPAREN:
                            print("closing parenthesis\n");
                            loop
                                op := peekop();
                                applyop();
                                if op == (UNARY_FLAG|OPENPAREN) then
                                    break;
                                end if;
                            end loop;
                            LexerGetToken();

                        when CLOSESQ:
                            print("closing square bracket\n");
                            loop
                                op := peekop();
                                applyop();
                                if (op == OPENSQ) or (op == OPENSQ_TYPE) then
                                    break;
                                end if;
                            end loop;
                            LexerGetToken();
                            
                        when else:
                            if (f & 0x0f) != 0 then
                                if (type_mode != 0) and (token == OPENSQ) then
                                    token := OPENSQ_TYPE;
                                    type_mode := 0;
                                end if;
                                pushop(token);
                                LexerGetToken();
                                break; # next token is a term
                            else
                                return;
                            end if;
                    end case;
                end loop;
            end loop;
        end sub;

        parse();
        while opsp != startopsp loop
            applyop();
        end loop;
        if sp != (startsp+1) then
            StartError();
            print("syntax error: unterminated expression at ");
            PrintTokenName(token);
            EndError();
        end if;
    end sub;

    sub ParseExpression(): (node: [Node]) is
        type_mode := 0;
        ParseRaw();
        node := PopNode();
    end sub;

    sub ParseType(): (type: [Type]) is
        type_mode := 1;
        ParseRaw();
        type := PopType();
    end sub;

    sub ParseVar() is
        LexerGetToken();
        var sym := ParseNewSymbol();
        var type: [Type] := 0 as [Type];
        if token == COLON then
            LexerGetToken();
            type := ParseType();
        end if;

        var value: [Node] := (0 as [Node]);
        if token == ASSIGN then
            LexerGetToken();
            value := ParseExpression();
            if type == (0 as [Type]) then
                type := value.type;
                if type == (0 as [Type]) then
                    SimpleError("types cannot be inferred for numeric constants");
                end if;
                if IsScalar(type) == 0 then
                    SimpleError("you can only assign scalar values");
                end if;
            end if;
        end if;

        if type == (0 as [Type]) then
            SimpleError("type inference can't be used with a value to infer from");
        end if;

        InitVariable(current_subr, sym, type);

        if value != (0 as [Node]) then
            CheckExpressionType(value, sym.vardata.type);
            var w := value.type.width as uint8;
            Generate(MidStore(w, value, MidDeref(w, MidAddress(sym, 0))));
        end if;

        RequireToken(SEMICOLON);
    end sub;

    sub ParseExpressionStatement() is
        var lvalue: [Node] := ParseExpression();
        case token is
            when SEMICOLON:
                # Bare expressions must be void procedure calls.

            when ASSIGN:
                # Either a simple or a multi assignment.

                RequireToken(ASSIGN);
                var rvalue: [Node] := ParseExpression();
                
                var type := lvalue.type;
                var address := UndoLValue(lvalue);
                CheckExpressionType(rvalue, type);
                var w := type.width as uint8;
                Generate(MidStore(w, rvalue, MidDeref(w, address)));

            when else:
                SyntaxError(token);
        end case;
        RequireToken(SEMICOLON);
    end sub;

    sub ParseIf() is
        LexerGetToken();

        PushIfData();
        true_label := AllocLabel();
        false_label := AllocLabel();
        exit_label := AllocLabel();
        false_generated := 0;

        var cond := ParseExpression();
        cond.beq.truelabel := true_label;
        cond.beq.falselabel := false_label;
        cond.beq.fallthrough := true_label;
        GenerateConditional(cond);

        RequireToken(THEN);
    end sub;

    sub CheckElseIsLast() is
        if false_generated != 0 then
            SimpleError("'else' must be last");
        end if;
    end sub;
    
    sub ParseElseif() is
        LexerGetToken();

        CheckStructure(IF);
        CheckElseIsLast();

        Generate(MidJump(exit_label));
        Generate(MidLabel(false_label));

        true_label := AllocLabel();
        false_label := AllocLabel();
        # false_generated is 0
        
        var cond := ParseExpression();
        cond.beq.truelabel := true_label;
        cond.beq.falselabel := false_label;
        cond.beq.fallthrough := true_label;
        GenerateConditional(cond);

        RequireToken(THEN);
    end sub;

    sub ParseElse() is
        LexerGetToken();

        CheckStructure(IF);
        CheckElseIsLast();

        Generate(MidJump(exit_label));
        Generate(MidLabel(false_label));
        false_generated := 1;
    end sub;
        
    sub ParseEndIf() is
        LexerGetToken();

        CheckStructure(IF);
        if false_generated == 0 then
            Generate(MidLabel(false_label));
        end if;
        Generate(MidLabel(exit_label));
        PopIfData();
    
        RequireToken(SEMICOLON);
    end sub;

    sub ParseLoop() is
        LexerGetToken();
        PushLoopData();

        break_label := AllocLabel();
        continue_label := AllocLabel();
        Generate(MidLabel(continue_label));
    end sub;
        
    sub ParseWhile() is
        ParseLoop();
        
        var cond := ParseExpression();
        cond.beq.truelabel := AllocLabel();
        cond.beq.falselabel := break_label;
        cond.beq.fallthrough := cond.beq.truelabel;
        GenerateConditional(cond);

        RequireToken(LOOP);
    end sub;

    sub ParseEndLoop() is
        LexerGetToken();
        Generate(MidJump(continue_label));
        Generate(MidLabel(break_label));

        PopLoopData();
        RequireToken(SEMICOLON);
    end sub;

    sub ParseContinue() is
        LexerGetToken();
        if continue_label == 0 then
            SimpleError("nowhere to continue to");
        end if;
        Generate(MidJump(continue_label));
        RequireToken(SEMICOLON);
    end sub;
    
    sub ParseBreak() is
        LexerGetToken();
        if break_label == 0 then
            SimpleError("nowhere to break to");
        end if;
        Generate(MidJump(break_label));
        RequireToken(SEMICOLON);
    end sub;

    sp := 0;
    opsp := 0;

    while token != EOF loop
        case token is
            when VAR:      ParseVar();
            when IF:       ParseIf();
            when ELSE:     ParseElse();
            when ELSEIF:   ParseElseif();
            when WHILE:    ParseWhile();
            when LOOP:     ParseLoop();
            when BREAK:    ParseBreak();
            when CONTINUE: ParseContinue();

            when END:
                LexerGetToken();
                case token is
                    when IF:   ParseEndIf();
                    when LOOP: ParseEndLoop();

                    when else:
                        SyntaxError(token);
                end case;

            when else:
                ParseExpressionStatement();
        end case;
    end loop;
end sub;
