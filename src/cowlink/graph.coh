# Hooks up all externals.

sub ResolveExternals() is
	var external: [External];
	var errors: uint8 := 0;

	# Find all external implementations.
	
	var subroutine := subroutines;
	while subroutine != (0 as [Subroutine]) loop
		if (subroutine.state & SUB_IMPLEMENTATION) != 0 then
			external := subroutine.external;
			if external != (0 as [External]) then
				if (external.impl != (0 as [Subroutine])) and (external.impl != subroutine) then
					SimpleError("conflicting externals");
				end if;
				external.impl := subroutine;
			end if;
		end if;
		subroutine := subroutine.next;
	end loop;

	# Now find any missing implementations.
	
	subroutine := subroutines;
	while subroutine != (0 as [Subroutine]) loop
		external := subroutine.external;
		if (external != (0 as [External])) and (external.impl == (0 as [Subroutine])) then
			print("error: external '");
			print(external.name);
			print("' unresolved\n");
			errors := 1;
		end if;
		subroutine := subroutine.next;
	end loop;

	if errors != 0 then
		SimpleError("aborting");
	end if;
end sub;

# Due to how interfaces are referenced, it's possible for a cycle
# to form in the linker if an interface does a passto statement to
# itself. 'cycle' is true if called or called's callees are the same as the subroutine.
sub DetectCycle(subroutine: [Subroutine], called: [Subroutine]): (cycle: uint8) is
	cycle := 0;
	if called.id == subroutine.id then
		cycle := 1;
	end if;
	var refs := &called.refs;
	while refs != (0 as [References]) loop
		var j: uint8 := 0;
		while j != COO_REFS_SIZE loop
			called := refs.calls[j];
			var tc := refs.is_tailcall[j];
			j := j + 1;
			if called == (0 as [Subroutine]) then
				break;
			end if;
			called := Deref(called);
			if called.id == subroutine.id and tc == 0 then
				cycle := 1;
			end if;
		end loop;
		refs := refs.next;
	end loop;
end sub;

# Walks the call graph, calculating both which subroutines are actually
# used and also allocating spaces in the subroutine workspaces.

sub PlaceSubroutines(subroutine: [Subroutine]) is
	const STACK_SIZE := 300;
	var stack: [Subroutine][STACK_SIZE];
	var sp: @indexof stack := 0;
	var i: uint8;

	i := 0;
	while i != NUM_WORKSPACES loop
		workspaceSize[i] := 0;
		i := i + 1;
	end loop;

	sub push(subr: [Subroutine]) is
		# Only add this subroutine to the stack if it's not already on it.
		var i: @indexof stack := sp;
		while i != 0 loop
			i := i - 1;
			if stack[i] == subr then
				return;
			end if;
		end loop;

		if sp == STACK_SIZE then
			print("error: dependency graph overflow\n");
			ExitWithError();
		end if;
		stack[sp] := subr;
		sp := sp + 1;
	end sub;

	push(subroutine);
	while sp != 0 loop
		sp := sp - 1;
		subroutine := stack[sp];
		subroutine.state := subroutine.state | SUB_USED;

		var watermark: Size[NUM_WORKSPACES];
		i := 0;
		while i != NUM_WORKSPACES loop
			var w := subroutine.workspaceAddress[i] + subroutine.workspaceSize[i];
			watermark[i] := ArchAlignUp(w, 8);
			if w > workspaceSize[i] then
				workspaceSize[i] := w;
			end if;

			i := i + 1;
		end loop;

		var refs := &subroutine.refs;
		while refs != (0 as [References]) loop
			var j: uint8 := 0;
			while j != COO_REFS_SIZE loop
				var called := refs.calls[j];
				var tc := refs.is_tailcall[j];
				j := j + 1;

				if called == (0 as [Subroutine]) then
					break;
				end if;
				called := Deref(called);

				i := 0;
				if tc != 0 and DetectCycle(subroutine, called) != 0 then
					continue;
				end if;
				while i != NUM_WORKSPACES loop
					var reqAddr: Size;
					var curAddr := called.workspaceAddress[i];
					if tc == 0 then
						reqAddr := watermark[i];
					else
						reqAddr := subroutine.workspaceAddress[i];
					end if;
					if reqAddr > curAddr then
						#print(subroutine.name);
						#print(" calling ");
						#print(called.name);
						#print(" -> ");
						#print_hex_i16(reqAddr);
						#print_nl();
						called.workspaceAddress[i] := reqAddr;
						# The subroutine's workspace has moved, so make sure it
						# gets reprocessed.
						push(called);
					end if;
					i := i + 1;
				end loop;
				if (called.state & SUB_USED) == 0 then
					# Subroutines which we know haven't been processed yet
					# always go on the queue.
					push(called);
					called.state := called.state | SUB_USED;
				end if;
			end loop;

			refs := refs.next;
		end loop;
	end loop;

	print("Workspace sizes:\n");
	i := 0;
	while i != NUM_WORKSPACES loop
		print("  #");
		print_i8(i);
		print(": ");
		print_i16(workspaceSize[i]);
		print(" bytes\n");
		i := i + 1;
	end loop;

#	subroutine := coo.subroutines;
#	var total: uint16 := 0;
#	var used: uint16 := 0;
#	loop
#		if subroutine == (0 as [Subroutine]) then
#			break;
#		end if;
#		if subroutine.used != 0 then
#			used := used + 1;
#		end if;
#		total := total + 1;
#		subroutine := subroutine.next;
#	end loop;
#	print_i16(total);
#	print(" subroutines total, of which ");
#	print_i16(used);
#	print(" are used\n");
end sub;

