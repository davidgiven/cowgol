%{
    const VARMEM_WS := 0;
    const PTRMEM_WS := 1;
    const VARSTACK_WS := 2;
    const PTRSTACK_WS := 3;

    var varsp: uint8 := 0;
    var ptrsp: uint8 := 0;
    var inasm: uint8 := 0;

    record ArchSubroutine is
        seen_return: uint8;
        end_label: LabelRef;
        rts_label: LabelRef;
        ptr_stack: uint8;
        var_stack: uint8;
    end record;

    record Extern is
        name: string;
        id: uint16;
        next: [Extern];
    end record;

    var externs: [Extern] := (0 as [Extern]);

    record Constant is
        value: Arith;
        lid: uint16;
        subr: [Subroutine];
        next: [Constant];
    end record;

    var constants: [Constant] := (0 as [Constant]);

    sub ArchAlignUp(value: Size, alignment: uint8): (newvalue: Size) is
        newvalue := value;
    end sub;

    sub is_zp(sym: [Symbol]): (result: uint8) is
        if (sym.wsid == PTRMEM_WS) or (sym.wsid == PTRSTACK_WS) then
            result := 1;
        else
            result := 0;
        end if;
    end sub;

    sub R_flushall() is
        RegCacheFlush(ALL_REGS);
    end sub;

    sub R_flush(reg: RegId) is
        RegCacheFlush(FindConflictingRegisters(reg));
    end sub;

    const OC_ADC := 0;
    const OC_SBC := 1;
    const OC_AND := 2;
    const OC_ORA := 3;
    const OC_EOR := 4;
    const OC_LDA := 5;
    const OC_LDX := 6;
    const OC_LDY := 7;
    const OC_STA := 8;
    const OC_STX := 9;
    const OC_STY := 10;
    const OC_PHP := 11;
    const OC_PHA := 12;
    const OC_PLP := 13;
    const OC_PLA := 14;
    const OC_TAX := 15;
    const OC_TXA := 16;
    const OC_TAY := 17;
    const OC_TYA := 18;
    const OC_BEQ := 19;
    const OC_BNE := 20;
    const OC_BVS := 21;
    const OC_BCC := 22;
    const OC_BCS := 23;
    const OC_CLC := 24;
    const OC_SEC := 25;
    const OC_RTS := 26;
    const OC_JSR := 27;
    const OC_JMP := 28;
    const OC_PHX := 29;
    const OC_PHY := 30;
    const OC_PLX := 31;
    const OC_PLY := 32;
    const OC_TSX := 33;
    const OC_TXS := 34;
    const OC_ROL := 35;
    const OC_STZ := 36;
    const OC_CMP := 37;
    const OC_CPX := 38;
    const OC_CPY := 39;
    const OC_INX := 40;
    const OC_INY := 41;
    const OC_DEX := 42;
    const OC_DEY := 43;
    const OC_INC := 44;
    const OC_DEC := 45;
    const OC_BRA := 46;
    const OC_BMI := 47;
    const OC_BPL := 48;
    const OC_ASL := 49;
    const OC_LSR := 50;

    sub E_oc(oc: uint8) is
        var ocs: string[] := {
            "adc", "sbc", "and", "ora", "eor", "lda", "ldx", "ldy",
            "sta", "stx", "sty", "php", "pha", "plp", "pla", "tax",
            "txa", "tay", "tya", "jeq", "jne", "jvs", "jcc", "jcs",
            "clc", "sec", "rts", "jsr", "jmp", "phx", "phy", "plx",
            "ply", "tsx", "txs", "rol", "stz", "cmp", "cpx", "cpy",
            "inx", "iny", "dex", "dey", "inc", "dec", "jra", "jmi",
            "jpl", "asl", "lsr"
        };

        E_tab();
        E(ocs[oc]);
        E_space();
    end sub;

    sub E_ocnl(oc: uint8) is
        E_oc(oc);
        E_nl();
    end sub;

    sub E_db() is E("\tdb "); end sub;
    sub E_dw() is E("\tdw "); end sub;
    sub E_dl() is E("\tdl "); end sub;

    sub E_plusone() is
        E("+1");
    end sub;

    sub E_label(label: LabelRef) is
        R_flushall();
        E_labelref(label);
        E(":\n");
    end sub;

    sub AllocPLabel(): (lid: uint16) is
        # Cheap and cheerful private label which doesn't conflict with anything
        # the front end allocated.
        lid := -AllocLabel();
    end sub;

    sub E_new_label(): (lid: uint16) is
        lid := AllocPLabel();
        E_label(lid);
    end sub;

    sub E_stackref(sid: uint16) is
        E_wsref(current_subr.id, (sid>>8) as uint8, sid & 0xff);
    end sub;

    sub E_stackrefi(sid: uint16) is
        E_openp();
        E_stackref(sid);
        E("),y");
    end sub;

    sub GetWsId(sym: [Symbol]): (wsid: uint8) is
        wsid := VARMEM_WS;
        if is_zp(sym) != 0 then
            wsid := PTRMEM_WS;
        end if;
    end sub;

    sub E_symref(sym: [Symbol], off: Size) is
		if sym.wsid == WSID_STATIC then
			E_wsref(sym.subr.id, sym.wsid, sym.off);
			if off != 0 then
				E_i16(off as int16);
			end if;
		else
			E_wsref(sym.subr.id, sym.wsid, sym.off + off);
		end if;
    end sub;

    sub E_y_nl()    is E(",y\n"); end sub;
    sub E_x_nl()    is E(",x\n"); end sub;
    sub E_lobyte()  is E(") & $ff\n"); end sub;
    sub E_hibyte()  is E(") / 256\n"); end sub;
    sub E_const()   is E_b8('#'); end sub;
    sub E_constop() is E("#("); end sub;

    sub E_jump(oc: uint8, label: LabelRef) is
        E_oc(oc);
        E_labelref(label);
        E_nl();
    end sub;

    sub E_jmp(label: LabelRef) is
        var oc: uint8;
        $ifdef ARCH_65C02
            oc := OC_BRA;
        $else
            oc := OC_JMP;
        $endif
        E_jump(oc, label);
    end sub;

    sub E_beq(label: LabelRef) is E_jump(OC_BEQ, label); end sub;
    sub E_bne(label: LabelRef) is E_jump(OC_BNE, label); end sub;
    sub E_bcs(label: LabelRef) is E_jump(OC_BCS, label); end sub;
    sub E_bmi(label: LabelRef) is E_jump(OC_BMI, label); end sub;
    sub E_bpl(label: LabelRef) is E_jump(OC_BPL, label); end sub;

    sub E_rts() is E_ocnl(OC_RTS); end sub;
    sub E_clc() is E_ocnl(OC_CLC); end sub;
    sub E_sec() is E_ocnl(OC_SEC); end sub;
    sub E_pha() is E_ocnl(OC_PHA); end sub;
    sub E_phx() is E_ocnl(OC_PHX); end sub;
    sub E_phy() is E_ocnl(OC_PHY); end sub;
    sub E_plp() is E_ocnl(OC_PLP); end sub;
    sub E_pla() is R_flush(REG_A); E_ocnl(OC_PLA); end sub;
    sub E_plx() is R_flush(REG_X); E_ocnl(OC_PLX); end sub;
    sub E_ply() is R_flush(REG_Y); E_ocnl(OC_PLY); end sub;
    sub E_txa() is R_flush(REG_A); E_ocnl(OC_TXA); end sub;
    sub E_tya() is R_flush(REG_A); E_ocnl(OC_TYA); end sub;
    sub E_tax() is R_flush(REG_X); E_ocnl(OC_TAX); end sub;
    sub E_tay() is R_flush(REG_Y); E_ocnl(OC_TAY); end sub;
    sub E_tsx() is R_flush(REG_X); E_ocnl(OC_TSX); end sub;
    sub E_rol() is R_flush(REG_A); E_ocnl(OC_ROL); end sub;
    sub E_txs() is E_ocnl(OC_TXS); end sub;
    sub E_not() is R_flush(REG_A); E_oc(OC_EOR); E("#255\n"); end sub;

    # Note: big endian on stack!
    sub E_phxa() is
        $ifdef ARCH_65C02
            E_pha();
            E_phx();
        $else
            E_pha();
            E_txa();
            E_pha();
        $endif
    end sub;

    # Note: big endian on stack!
    sub E_plxa() is
        $ifdef ARCH_65C02
            E_plx();
            E_pla();
        $else
            E_pla();
            E_tax();
            E_pla();
        $endif
    end sub;

    sub E_ld(reg: RegId) is
        R_flush(reg);
        case reg is
            when REG_A: E_oc(OC_LDA);
            when REG_X: E_oc(OC_LDX);
            when REG_Y: E_oc(OC_LDY);
        end case;
    end sub;

    sub E_st(reg: RegId) is
        R_flush(reg);
        case reg is
            when REG_A: E_oc(OC_STA);
            when REG_X: E_oc(OC_STX);
            when REG_Y: E_oc(OC_STY);
        end case;
    end sub;

    sub E_lda() is E_ld(REG_A); end sub;
    sub E_ldx() is E_ld(REG_X); end sub;
    sub E_ldy() is E_ld(REG_Y); end sub;
    sub E_sta() is E_st(REG_A); end sub;
    sub E_stx() is E_st(REG_X); end sub;
    sub E_sty() is E_st(REG_Y); end sub;
    sub E_stz() is E_oc(OC_STZ); end sub;

    sub E_cp(reg: RegId) is
        case reg is
            when REG_A: E_oc(OC_CMP);
            when REG_X: E_oc(OC_CPX);
            when REG_Y: E_oc(OC_CPY);
        end case;
    end sub;

    sub E_cmp() is E_cp(REG_A); end sub;
    sub E_cpx() is E_cp(REG_X); end sub;
    sub E_cpy() is E_cp(REG_Y); end sub;

    sub E_inc() is E_oc(OC_INC); end sub;
    sub E_dec() is E_oc(OC_DEC); end sub;
    
    sub E_a() is E_b8('a'); end sub;

    sub E_ina() is R_flush(REG_X); E_inc(); E_a(); end sub;
    sub E_dea() is R_flush(REG_X); E_dec(); E_a(); end sub;

    sub E_inx() is R_flush(REG_X); E_ocnl(OC_INX); end sub;
    sub E_iny() is R_flush(REG_Y); E_ocnl(OC_INY); end sub;
    sub E_dex() is R_flush(REG_X); E_ocnl(OC_DEX); end sub;
    sub E_dey() is R_flush(REG_Y); E_ocnl(OC_DEY); end sub;

    sub E_increment(reg: RegId) is
        case reg is
            when REG_A:
                R_flush(REG_A);
                $ifdef ARCH_65C02
                    E_inc();
                    E("a\n");
                $else
                    E_clc();
                    E_oc(OC_ADC);
                    E("#1\n");
                $endif

            when REG_X: E_inx();
            when REG_Y: E_iny();
        end case;
    end sub;

    sub E_decrement(reg: RegId) is
        case reg is
            when REG_A:
                R_flush(REG_A);
                $ifdef ARCH_65C02
                    E_dec();
                    E("a\n");
                $else
                    E_sec();
                    E_oc(OC_SBC);
                    E("#1\n");
                $endif

            when REG_X: E_dex();
            when REG_Y: E_dey();
        end case;
    end sub;

    sub IsSimpleSub(subr: [Subroutine]): (result: uint8) is
        result := 0;
        if ((subr.flags & SUB_IS_IMPLEMENTATION) != 0) and (subr.num_input_parameters > 0) then
            return;
        end if;
        if (subr.num_output_parameters > 1) or (subr.num_input_parameters > 1) then
            return;
        end if;
        if subr.num_input_parameters == 1 then
            var param := GetInputParameter(subr, 0);
            if param.width == 4 then
                return;
            end if;
        end if;
        if subr.num_output_parameters == 1 then
            param := GetOutputParameter(subr, 0);
            if param.width == 4 then
                return;
            end if;
        end if;
        result := 1;
    end sub;

    sub E_call(subr: [Subroutine]) is
        R_flushall();
        E_oc(OC_JSR);
        E_subref(subr);
        E_nl();
    end sub;

    sub E_loadconst(reg: RegId, value: uint8) is
        var cache := RegCacheFindConstant(value);
        if (cache & reg) == 0 then
            if (reg == REG_A) and ((cache & ((REG_X|REG_Y))) != 0) then
                if (cache & REG_X) != 0 then
                    E_txa();
                else
                    E_tya();
                end if;
            elseif ((reg & (REG_X|REG_Y)) != 0) and ((cache & REG_A) != 0) then
                if (reg & REG_X) != 0 then
                    E_tax();
                else
                    E_tay();
                end if;
            else
                $ifdef ARCH_65C02
                    const INCABLE := REG_A|REG_X|REG_Y;
                $else
                    const INCABLE := REG_X|REG_Y;
                $endif
                cache := RegCacheFindConstant(value-1) & reg & INCABLE;
                if cache != 0 then
                    E_increment(reg);
                else
                    cache := RegCacheFindConstant(value+1) & reg & INCABLE;
                    if cache != 0 then
                        E_decrement(reg);
                    else
                        E_ld(reg);
                        E_const();
                        E_u8(value);
                        E_nl();
                    end if;
                end if;
            end if
        end if;
        RegCacheLeavesConstant(reg, value);
    end sub;

    sub E_loadaddr(sym: [Symbol], off: Size) is
        E_lda();
        E_constop();
        E_symref(sym, off);
        E_lobyte();

        E_ldx();
        E_constop();
        E_symref(sym, off);
        E_hibyte();
    end sub;

    sub E_loadsubref(subr: [Subroutine]) is
        E_lda();
        E_constop();
        E_subref(subr);
        E_lobyte();
        E_nl();

        E_ldx();
        E_constop();
        E_subref(subr);
        E_hibyte();
        E_nl();
    end sub;

    sub E_loadstackref(sid: uint16) is
        E_lda();
        E_constop();
        E_stackref(sid);
        E_lobyte();
        E_nl();

        E_ldx();
        E_constop();
        E_stackref(sid);
        E_hibyte();
        E_nl();
    end sub;

    sub GetHelper(name: string): (e: [Extern]) is
        e := externs;
        while e != (0 as [Extern]) loop
            if StrCmp(e.name, name) == 0 then
                break;
            end if;
            e := e.next;
        end loop;

        if e == (0 as [Extern]) then
            e := InternalAlloc(@bytesof Extern) as [Extern];
            e.name := name;
            e.id := AllocSubrId();
            e.next := externs;
            externs := e;

            EmitterDeclareExternalSubroutine(e.id, name);
        end if;
    end sub;

    # Does not persist the name; only call this with constant strings.
    sub E_callhelper(name: string) is
        var e := GetHelper(name);

        EmitterReferenceSubroutineById(current_subr.id, e.id, 0);

        R_flushall();
        E_oc(OC_JSR);
        E_b8(COO_ESCAPE_SUBREF);
        E_b16(e.id);
        E_nl();
    end sub;

    sub E_jumps_with_fallthrough(trueoc: uint8, falseoc: uint8, node: [Node]) is
        if node.beq.truelabel != node.beq.fallthrough then
            E_jump(trueoc, node.beq.truelabel);
        end if;
        if node.beq.falselabel != node.beq.fallthrough then
            E_jump(falseoc, node.beq.falselabel);
        end if;
    end sub;

    sub E_jumps_beq_bne(node: [Node]) is E_jumps_with_fallthrough(OC_BEQ, OC_BNE, node); end sub; 
    sub E_jumps_bcs_bcc(node: [Node]) is E_jumps_with_fallthrough(OC_BCS, OC_BCC, node); end sub; 
    sub E_jumps_bcc_bcs(node: [Node]) is E_jumps_with_fallthrough(OC_BCC, OC_BCS, node); end sub; 
    sub E_jumps_bmi_bpl(node: [Node]) is E_jumps_with_fallthrough(OC_BMI, OC_BPL, node); end sub; 

    sub AllocConst(value: Arith): (lid: uint16) is
        var c := constants;
        while c != (0 as [Constant]) loop
            if c.value == value then
                break;
            end if;
            c := c.next;
        end loop;
        if c == (0 as [Constant]) then
            c := InternalAlloc(@bytesof Constant) as [Constant];
            c.lid := AllocPLabel();
            c.value := value;
            c.subr := current_subr;
            c.next := constants;
            constants := c;
        end if;
        lid := c.lid;
    end sub;

    sub E_string(data: string): (lid: uint16) is
        lid := AllocPLabel();

        EmitterOpenStream(current_subr);

        E_label(lid);
        E_db();

        loop
            var c := [data];
            if c == 0 then
                break;
            end if;
            data := data + 1;
            
            E_u8(c);
            E_comma();
        end loop;
        E("0\n");
        EmitterCloseStream();
    end sub;

    sub ArchEndInstruction() is
    end sub;
%}

wordsize uint8;

register a x y xa;
register v8;  // value on fake stack
register v16; // value on fake stack
register p16; // pointer on fake stack
register v32; // value on fake stack;
register const address;
register mem1 mem2 mem2p mem4;
$ifndef TINY
    register memi1 memi2 memi4;
    register stacki1 stacki2 stacki4;
$endif
register param;

regclass r8 := a|x|y;
regclass a16 := v16|p16;
$ifndef TINY
    regclass in1s := const|mem1|memi1|stacki1|v8;
    regclass in2s := const|address|mem2|memi2|stacki2|a16;
    regclass in4s := const|mem4|memi4|stacki4|v32;
    regclass ptrs := mem2p|address|p16;
    regclass derefs := memi1|memi2|memi4|stacki1|stacki2|stacki4;
$else
    regclass in1s := const|mem1|v8;
    regclass in2s := const|address|mem2|a16;
    regclass in4s := const|mem4|v32;
    regclass ptrs := mem2p|address|p16;
$endif

regdata a           uses xa|a compatible a|x|y;
regdata x           uses xa|x compatible a|x;
regdata y                     compatible a|y;
regdata xa          uses x|a  compatible xa;
regdata v8  stacked;
regdata v16 stacked;
regdata p16 stacked;
regdata v32 stacked;
regdata param stacked;
regdata const stacked;
regdata mem1 stacked;
regdata mem2 stacked;
regdata mem2p stacked;
regdata mem4 stacked;
regdata address stacked;
regdata const stacked;
$ifndef TINY
    regdata memi1 stacked;
    regdata memi2 stacked;
    regdata memi4 stacked;
    regdata stacki1 stacked;
    regdata stacki2 stacked;
    regdata stacki4 stacked;
$endif

// --- Core things ----------------------------------------------------------

gen STARTFILE();

gen ENDFILE();

gen LABEL():b uses all
{
    R_flushall();
    E_labelref($b.label);
    E(":\n");
}

gen JUMP():j uses all
{
    E_jmp($j.label);
}

// --- MOperands -------------------------------------------------------------

%{
    const MODE_SYMBOLI := 0;
    const MODE_STACKI := 1;
    const MODE_CONST := 2;
    const MODE_ADDRESS := 3;
    const MODE_SYMBOL := 4;
    const MODE_STACK := 5;

    record StackOp is
        sid: uint16;
        wsid: uint8;
        width: uint8;
    end record;

    record MOperand is
        stk @at(0): StackOp;
        off @at(0): Size;
        val @at(0): Arith;
        sym: [Symbol];
        mode: uint8;
        next: [MOperand];
    end record;

    const OPERAND_STACK_SIZE := 16;
    var opstack: [MOperand][OPERAND_STACK_SIZE];
    var first_operand: [MOperand] := 0 as [MOperand];
    var opsp: uint8 := 0;

    sub RegWidth(reg: RegId): (width: uint8) is
        if (reg & REG_V8) != 0 then
            width := 1;
        elseif (reg & (REG_V16|REG_P16)) != 0 then
            width := 2;
        elseif (reg & REG_V32) != 0 then
            width := 4;
        else
            SimpleError("bad reg");
        end if;
    end sub;

    sub CleanupMOperands() is
        while first_operand != (0 as [MOperand]) loop
            var n := first_operand.next;
            Free(first_operand as [uint8]);
            first_operand := n;
        end loop;
    end sub;

    sub PushOp(): (op: [MOperand]) is
        if opsp == OPERAND_STACK_SIZE then
            SimpleError("opstack overflow");
        end if;
        op := InternalAlloc(@bytesof MOperand) as [MOperand];
        opstack[opsp] := op;
        opsp := opsp + 1;
    end sub;

    sub PushConstOp(value: Arith): (op: [MOperand]) is
        op := PushOp();
        op.mode := MODE_CONST;
        op.val := value;
    end sub;
        
    sub PushAddressOp(sym: [Symbol], off: Size): (op: [MOperand]) is
        op := PushOp();
        op.mode := MODE_ADDRESS;
        op.sym := sym;
        op.off := off;
    end sub;
        
    sub PushSymOp(sym: [Symbol], off: Size): (op: [MOperand]) is
        op := PushOp();
        op.mode := MODE_SYMBOL;
        op.sym := sym;
        op.off := off;
    end sub;
        
    sub PushSymIOp(sym: [Symbol], off: Size): (op: [MOperand]) is
        op := PushOp();
        op.mode := MODE_SYMBOLI;
        op.sym := sym;
        op.off := off;
    end sub;
        
    sub PushStackOp(reg: RegId, width: uint8): (op: [MOperand]) is
        var sid: uint16;
        if (reg & REG_P16) != 0 then
            sid := (PTRSTACK_WS<<8) | (ptrsp as uint16);
            ptrsp := ptrsp + width;
            if current_subr.arch.ptr_stack < ptrsp then
                current_subr.arch.ptr_stack := ptrsp;
            end if;
        else
            sid := (VARSTACK_WS<<8) | (varsp as uint16);
            varsp := varsp + width;
            if current_subr.arch.var_stack < varsp then
                current_subr.arch.var_stack := varsp;
            end if;
        end if;

        op := PushOp();
        op.mode := MODE_STACK;
        op.stk.sid := sid;
        op.stk.wsid := (op.stk.sid >> 8) as uint8;
        op.stk.width := width;
    end sub;

    sub PushV32(): (op: [MOperand]) is
        op := PushStackOp(REG_V32, 4);
    end sub;

    sub PopOp(): (op: [MOperand]) is
        if opsp == 0 then
            SimpleError("opstack underflow");
        end if;
        opsp := opsp - 1;
        op := opstack[opsp];

        if (op.mode == MODE_STACK) or (op.mode == MODE_STACKI) then
            case op.stk.wsid is
                when PTRSTACK_WS:
                    ptrsp := ptrsp - op.stk.width;

                when VARSTACK_WS:
                    varsp := varsp - op.stk.width;
            end case;
        end if;
    end sub;

    sub PeekOp(): (op: [MOperand]) is
        if opsp == 0 then
            SimpleError("opstack underflow");
        end if;
        op := opstack[opsp-1];
    end sub;

    sub DerefOp(op: [MOperand]) is
        case op.mode is
            when MODE_ADDRESS: op.mode := MODE_SYMBOL;
            when MODE_SYMBOL:  op.mode := MODE_SYMBOLI;
            when MODE_STACK:   op.mode := MODE_STACKI;
            when else:         SimpleError("can't deref");
        end case;
    end sub;

    sub PopAndDerefOp(): (op: [MOperand]) is
        op := PopOp();
        DerefOp(op);
    end sub;

    sub DoParamIndirect(operand: [MOperand], oc: uint8, off: Size) is
        sub CheckSize() is
            if off != 0 then
                SimpleError("bad indirect");
            end if;
        end sub;

        E_oc(oc);
        case operand.mode is
            when MODE_CONST:
                E_labelref(AllocConst(operand.val));

            when MODE_STACK:
                E_stackref(operand.stk.sid);

            when MODE_STACKI:
                CheckSize();
                E_openp();
                E_stackref(operand.stk.sid);
                E_closep();

            when MODE_SYMBOLI:
                CheckSize();
                E_openp();
                E_symref(operand.sym, operand.off);
                E_closep();

            when MODE_SYMBOL:
                E_symref(operand.sym, operand.off);

            when else:
                StartError();
                print("bad indirect mode ");
                print_i8(operand.mode);
                EndError();
        end case;
        if off != 0 then
            E_i16(off as int16);
        end if;
        E_y_nl();
    end sub;

    sub DoParamIndirect_lda(operand: [MOperand]) is R_flush(REG_A); DoParamIndirect(operand, OC_LDA, 0); end sub; 
    sub DoParamIndirect_sta(operand: [MOperand]) is                 DoParamIndirect(operand, OC_STA, 0); end sub; 
    sub DoParamIndirect_sbc(operand: [MOperand]) is R_flush(REG_A); DoParamIndirect(operand, OC_SBC, 0); end sub;

    sub DoParamDirect(operand: [MOperand], oc: uint8, offset: uint8) is
        var m := operand.mode;

        if (m == MODE_STACKI) or (m == MODE_SYMBOLI) then
            $ifdef ARCH_65C02
                if offset != 0 then
                    E_loadconst(REG_Y, offset);
                end if;
            $else
                E_loadconst(REG_Y, offset);
            $endif
        end if;

        E_oc(oc);
        case operand.mode is
            when MODE_CONST:
                E_const();
                E_u8((operand.val >> (8*offset)) as uint8);

            when MODE_ADDRESS:
                E_constop();
                E_symref(operand.sym, operand.off);
                case offset is
                    when 0: E_lobyte();
                    when 1: E_hibyte();
                end case;

            when MODE_STACK:
                E_stackref(operand.stk.sid + (offset as uint16));

            when MODE_SYMBOL:
                E_symref(operand.sym, operand.off + (offset as uint16));

            when MODE_STACKI:
                E_openp();
                E_stackref(operand.stk.sid);
                E_closep();
                $ifdef ARCH_65C02
                    if offset != 0 then
                        E(",y");
                    end if;
                $else
                    E(",y");
                $endif

            when MODE_SYMBOLI:
                E_openp();
                E_symref(operand.sym, operand.off);
                E_closep();
                $ifdef ARCH_65C02
                    if offset != 0 then
                        E(",y");
                    end if;
                $else
                    E(",y");
                $endif

            when else:
                StartError();
                print("bad direct mode ");
                print_i8(operand.mode);
                EndError();
        end case;
        E_nl();
    end sub;

    sub DoParamDirect_lda(operand: [MOperand], offset: uint8) is R_flush(REG_A); DoParamDirect(operand, OC_LDA, offset); end sub;
    sub DoParamDirect_ldy(operand: [MOperand], offset: uint8) is R_flush(REG_A); DoParamDirect(operand, OC_LDY, offset); end sub;
    sub DoParamDirect_sta(operand: [MOperand], offset: uint8) is                 DoParamDirect(operand, OC_STA, offset); end sub;

    sub ArchBeginComment() is
        E("\t; ");
    end sub;

    sub ArchEndComment() is
        E_nl();
    end sub;

    # Note that this *destroys* the source register.
    sub ArchEmitMove(src: RegId, dest: RegId) is
        var sid: uint16;

        sub PopXY(transoc: uint8) is
            var op := PushStackOp(REG_V8, 1);
            DoParamDirect_sta(op, 0);
            E_pla();
            E_ocnl(transoc);
            R_flush(REG_A);
            DoParamDirect_lda(op, 0);
            op := PopOp();
        end sub;

        case src is
            when REG_A:
                case dest is
                    when REG_X: E_tax(); return;
                    when REG_Y: E_tay(); return;
                    when 0:     E_pha(); return;
                end case;

            when 0:
                case dest is
                    when REG_A:  E_pla(); return;
                    $ifdef ARCH_65C02
                        when REG_X: E_plx(); return;
                        when REG_Y: E_ply(); return;
                    $else
                        when REG_X: PopXY(OC_TAX); return;
                        when REG_Y: PopXY(OC_TAY); return;
                    $endif

                    when REG_XA:
                        E_plxa();
                        return;
                end case;

            when REG_X:
                case dest is
                    when REG_A:  E_txa(); return;
                    $ifdef ARCH_65C02
                        when 0: E_phx(); return;
                    $endif
                end case;

            when REG_Y:
                case dest is
                    when REG_A:  E_tya(); return;
                    $ifdef ARCH_65C02
                        when 0: E_phy(); return;
                    $endif
                end case;

            when REG_XA:
                case dest is
                    when 0:
                        E_phxa();
                        return;
                end case;
        end case;

        StartError();
        print("bad move ");
        print_hex_i32(src as uint32);
        print(" -> ");
        print_hex_i32(dest as uint32);
        EndError();
    end sub;

    sub ArchEndGroup() is
        if inasm == 0 then
            E_nl();
        end if;

        CleanupMOperands();
    end sub;
%}

gen const := CONSTANT():c                        { var op := PushConstOp($c.value); }
gen address := ADDRESS():a                       { var op := PushAddressOp(&$a.sym, $a.off); }
gen mem1 := DEREF1(ADDRESS():a)                   { var op := PushSymOp(&$a.sym, $a.off); }
gen mem2 := DEREF2(ADDRESS():a)                   { var op := PushSymOp(&$a.sym, $a.off); }
gen mem2p := DEREF2(ADDRESS(&sym is zp):a)         { var op := PushSymOp(&$a.sym, $a.off); }
gen mem4 := DEREF4(ADDRESS():a)                   { var op := PushSymOp(&$a.sym, $a.off); }
$ifndef TINY
    gen memi1 := DEREF1(DEREF2(ADDRESS(&sym is zp):a))  { var op := PushSymIOp(&$a.sym, $a.off); }
    gen memi2 := DEREF2(DEREF2(ADDRESS(&sym is zp):a))  { var op := PushSymIOp(&$a.sym, $a.off); }
    gen memi4 := DEREF4(DEREF2(ADDRESS(&sym is zp):a))  { var op := PushSymIOp(&$a.sym, $a.off); }
    gen stacki1 := DEREF1(p16)                        { var op := PeekOp(); op.mode := MODE_STACKI; }
    gen stacki2 := DEREF2(p16)                        { var op := PeekOp(); op.mode := MODE_STACKI; }
    gen stacki4 := DEREF4(p16)                        { var op := PeekOp(); op.mode := MODE_STACKI; }
$endif

// ==========================================================================
//                        STRICTLY NECESSARY RULES
// ==========================================================================

// These rules are required for the code generator to work at all.

// --- Subroutines ----------------------------------------------------------

gen STARTSUB() uses all
{
    current_subr.arch := InternalAlloc(@bytesof ArchSubroutine) as [ArchSubroutine];
    current_subr.arch.end_label := AllocPLabel();
    current_subr.arch.rts_label := AllocPLabel();

    RegCacheReset();

    EmitterOpenStream(current_subr);

    E("\n\n\t; ");
    E(current_subr.name);
    E_nl();

    if (current_subr.flags & SUB_IS_INTERFACE) == 0 then
        E_b8(COO_ESCAPE_THISSUB);
        E(":\n");

        var count := current_subr.num_input_parameters;
        var lastparam := count - 1;
        var popped: uint8 := 0;

        sub PopReturnAddress() is
            if popped == 0 then
                $ifdef ARCH_65C02
                    E_plx();
                    E_ply();
                $else
                    E_pla();
                    E_tax();
                    E_pla();
                    E_tay();
                $endif
                E_inx();

                E_stx();
                E_labelref(current_subr.arch.rts_label);
                E_nl();

                var label := AllocPLabel();
                E_bne(label);

                E_iny();

                E_label(label);
                E_sty();
                E_labelref(current_subr.arch.rts_label);
                E_plusone();
                E_nl();

                popped := 1;
            end if;
        end sub;

        var current_subrid: uint16;
        var current_wsid: uint8 := 0xff;
        var current_top: Size;
        var current_bot: Size;

        sub CloseLoop() is
            if current_wsid != 0xff then
                var count := current_top - current_bot + 1;

                if count == 2 then
                    E_pla();

                    E_sta();
                    E_wsref(current_subrid, current_wsid, current_bot+1);
                    E_nl();

                    count := 1;
                end if;
                if count == 1 then
                    E_pla();

                    E_sta();
                    E_wsref(current_subrid, current_wsid, current_bot);
                    E_nl();
                end if;
                if count > 2 then
                    E_loadconst(REG_Y, (count as uint8)-1);
                    var lid := E_new_label();
                    E_pla();
                    
                    E_sta();
                    E_wsref(current_subrid, current_wsid, current_bot);
                    E_y_nl();

                    E_dey();
                    E_bpl(lid);
                end if;
            end if;
            current_wsid := 0xff;
        end sub;

        var param: [Symbol];
        sub Pull() is
            var wsid := GetWsId(param);
            var w := param.width as Size;
            if (wsid != current_wsid) or (param.subr.id != current_subrid)
                    or (param.off != (current_bot-w)) then
                CloseLoop();
                current_wsid := wsid;
                current_subrid := param.subr.id;
                current_top := param.off + w - 1;
            end if;
            current_bot := param.off;
        end sub;

        while count != 0 loop
            count := count - 1;
            param := GetInputParameter(current_subr, count) as [Symbol];

            var inregister: uint8 := 0;
            if (count == lastparam) and ((current_subr.flags & SUB_IS_IMPLEMENTATION) == 0) then
                inregister := 1;
            end if;
            case param.width is
                when 1:
                    if inregister == 0 then
                        PopReturnAddress();
                        Pull();
                    else
                        E_sta();
                        E_symref(param, 0);
                        E_nl();
                        RegCacheLeavesValue(REG_A, param, 0);
                    end if;

                when 2:
                    if inregister == 0 then
                        PopReturnAddress();
                        Pull();
                    else
                        E_sta();
                        E_symref(param, 0);
                        E_nl();

                        E_stx();
                        E_symref(param, 1);
                        E_nl();

                        RegCacheLeavesValue(REG_XA, param, 0);
                    end if;

                when 4:
                    # WARNING: little endian on stack!
                    PopReturnAddress();
                    Pull();
            end case;
        end loop;
        CloseLoop();

        if IsSimpleSub(current_subr) == 0 then
            PopReturnAddress();
        end if;
    end if;
}

gen ENDSUB() uses all
{
    if (current_subr.flags & SUB_IS_INTERFACE) == 0 then
        if current_subr.arch.seen_return != 0 then
            E_label(current_subr.arch.end_label);
        end if;

        var current_subrid: uint16;
        var current_wsid: uint8 := 0xff;
        var current_top: Size;
        var current_bot: Size;

        sub CloseLoop() is
            if current_wsid != 0xff then
                var count := current_top - current_bot + 1;

                if count <= 2 then
                    E_lda();
                    E_wsref(current_subrid, current_wsid, current_bot);
                    E_nl();

                    E_pha();
                end if;
                if count == 2 then
                    E_lda();
                    E_wsref(current_subrid, current_wsid, current_bot+1);
                    E_nl();

                    E_pha();
                end if;
                if count > 2 then
                    E_loadconst(REG_Y, 256-(count as uint8));
                    var lid := E_new_label();
                    E_lda();
                    E_wsref(current_subrid, current_wsid, current_bot - (256 - count));
                    E_y_nl();
                    
                    E_pha();

                    E_iny();
                    E_bne(lid);
                end if;
            end if;
            current_wsid := 0xff;
        end sub;

        var param: [Symbol];
        sub Push() is
            var wsid := GetWsId(param);
            var w := param.width;
            if (wsid != current_wsid) or (param.subr.id != current_subrid)
                    or (param.off != (current_top+1)) then
                CloseLoop();
                current_subrid := param.subr.id;
                current_wsid := wsid;
                current_bot := param.off;
            end if;
            current_top := param.off + (w as Size) - 1;
        end sub;

        var i: uint8 := 0;
        var count := current_subr.num_output_parameters;
        while i != count loop
            param := GetOutputParameter(current_subr, i) as [Symbol];

            var cache: RegId;
            case param.width is
                when 1:
                    if i == (count - 1) then
                        CloseLoop();

                        cache := RegCacheFindValue(param, 0) & REG_A;
                        if cache == 0 then
                            E_lda();
                            E_symref(param, 0);
                            E_nl();
                        end if;
                    else
                        Push();
                    end if;

                when 2:
                    if i == (count - 1) then
                        CloseLoop();

                        cache := RegCacheFindValue(param, 0) & REG_XA;
                        if cache == 0 then
                            E_lda();
                            E_symref(param, 0);
                            E_nl();

                            E_ldx();
                            E_symref(param, 1);
                            E_nl();
                        end if;
                    else
                        Push();
                    end if;

                when 4:
                    Push();
            end case;
            i := i + 1;
        end loop;
        CloseLoop();

        if IsSimpleSub(current_subr) != 0 then
            E_rts();
        else
            E_labelref(current_subr.arch.rts_label);
            E("=*+1\n");
            E("\tjmp $ffff\n");
        end if;

        var p := 0 as [Constant];
        var c := constants;
        while c != (0 as [Constant]) loop
            if c.subr == current_subr then
                E_label(c.lid);
                E("\t.dword ");
                E_u32(c.value as uint32);
                E_nl();

                if p == (0 as [Constant]) then
                    constants := c.next;
                else
                    p.next := c.next;
                end if;
                var nc := c;
                c := c.next;
                Free(nc as [uint8]);
            else
                p := c;
                c := c.next;
            end if;
        end loop;
    end if;

    EmitterCloseStream();

    EmitterDeclareWorkspace(current_subr.id, PTRSTACK_WS, current_subr.arch.ptr_stack as uint16);
    EmitterDeclareWorkspace(current_subr.id, VARSTACK_WS, current_subr.arch.var_stack as uint16);

    Free(current_subr.arch as [uint8]);
}

gen RETURN() uses all
{
    if (IsSimpleSub(current_subr) != 0) and (current_subr.num_output_parameters == 0) then
        E_rts();
    else
        current_subr.arch.seen_return := 1;
        E_jmp(current_subr.arch.end_label);
    end if;
}

%{
    sub PopArg4(dest: [MOperand]) is
        # WARNING: lowest byte on stack is MSB, so pop the MSB first!
        E_loadconst(REG_Y, 3);
        var lid := E_new_label();

        E_pla();
        DoParamIndirect_sta(dest);
        E_dey();
        E_bpl(lid);
    end sub;

    sub Call(addr: [MidcodeSubref]) is
        E_call(addr.subr);
    end sub;

    sub CallI() is
        E_callhelper("_jmpxa");
    end sub;

    sub is_fast(subr: [Subroutine]): (result: uint8) is
        if (subr.flags & SUB_IS_IMPLEMENTATION) == 0 then
            result := 1;
        else
            result := 0;
        end if;
    end sub;
%}

gen        CALL(       param,      SUBREF():a)             uses all { Call(&$a); }
gen        CALL(  ARG1(param, a),  SUBREF(subr is fast):a) uses all { Call(&$a); }
gen        CALL(  ARG2(param, xa), SUBREF(subr is fast):a) uses all { Call(&$a); }

gen        CALL(  param, xa) uses all { CallI(); }

gen param := END();

gen param := ARG1(param, a) { E_pha(); } 
gen param := ARG2(param, xa) { E_phxa(); }

gen param := ARG4(param, in4s:lhs) uses y|a
{
    var op := PopOp();
    var lid := AllocPLabel();

    # WARNING: lowest byte on stack is MSB, so push the LSB first!
    $ifndef TINY
    if ($lhs & REGCLASS_DEREFS) != 0 then
        E_loadconst(REG_X, 4);
        E_loadconst(REG_Y, 0);
        E_label(lid);

        DoParamIndirect_lda(op);
        E_pha();
        E_iny();
        E_dex();
    else
    $endif

        E_loadconst(REG_Y, 252);
        E_label(lid);

        DoParamIndirect(op, OC_LDA, -252);
        E_pha();
        E_iny();

    $ifndef TINY
    end if;
    $endif

    E_bne(lid);
}

gen a := POPARG1(remaining==0);
gen a := POPARG1(remaining!=0) { E_pla(); } 
gen xa := POPARG2(remaining==0);

gen xa := POPARG2(remaining!=0) { E_plxa(); }

gen v32 := POPARG4()               uses x|y|a { PopArg4(PushV32()); }
gen STORE4(POPARG4(), DEREF4(ptrs)) uses x|y|a { PopArg4(PopAndDerefOp()); }

// --- 8-bit -----------------------------------------------------------------

gen v8 := FALLBACK(a|x|y:rhs) cost -1000
{
    var op := PushStackOp($$, 1);
    E_st($rhs);
    E_stackref(op.stk.sid);
    E_nl();
}

gen a := FALLBACK(v8) uses y cost -1000
{
    var op := PopOp();
    DoParamDirect_lda(op, 0);
}

gen a|x|y := CONSTANT():c
{
    E_loadconst($$, $c.value as uint8);
}

gen STORE1(a:lhs, DEREF1(ptrs)) uses y
{
    var op := PopAndDerefOp();

    DoParamDirect_sta(op, 0);
}

gen STORE1(a|x|y:lhs, DEREF1(ADDRESS():a))
{
    E_st($lhs);
    E_symref(&$a.sym, $a.off);
    E_nl();
    RegCacheLeavesValue($lhs, &$a.sym, $a.off);
}

gen a|x|y := DEREF1(ADDRESS():a)
{
    var cache := RegCacheFindValue(&$a.sym, $a.off) & $$;
    if cache == 0 then
        E_ld($$);
        E_symref(&$a.sym, $a.off);
        E_nl();
        RegCacheLeavesValue($$, &$a.sym, $a.off);
    end if;
}

gen a := DEREF1(ptrs) uses y
{
    var op := PopAndDerefOp();

    DoParamDirect_lda(op, 0);
}

gen a := NOT1(a)
        { E_not(); }

gen a := NEG1(a)
{
    R_flush(REG_A);
    E_sec();
    E_not();
    E("\tadc #0\n");
}

gen a := ADD1(a, in1s) uses y { E_clc(); DoParamDirect(PopOp(), OC_ADC, 0); }
gen a := SUB1(a, in1s) uses y { E_sec(); DoParamDirect(PopOp(), OC_SBC, 0); }
gen a := OR1 (a, in1s) uses y {          DoParamDirect(PopOp(), OC_ORA, 0); }
gen a := AND1(a, in1s) uses y {          DoParamDirect(PopOp(), OC_AND, 0); }
gen a := EOR1(a, in1s) uses y {          DoParamDirect(PopOp(), OC_EOR, 0); }

gen a := LSHIFT1(a, y)  { E_callhelper("_lshift1"); }
gen a := RSHIFTU1(a, y) { E_callhelper("_rshiftu1"); }
gen a := RSHIFTS1(a, y) { E_callhelper("_rshifts1"); }

gen a := MUL1(a, x) uses y  { E_callhelper("_mul1"); }
gen a := DIVU1(a, x) uses y { E_callhelper("_divu1"); }
gen x := REMU1(a, x) uses y { E_callhelper("_divu1"); }
gen a := DIVS1(a, x) uses y { E_callhelper("_divs1"); }
gen x := REMS1(a, x) uses y { E_callhelper("_divs1"); }

// --- 16-bit ---------------------------------------------------------------

gen a16 := FALLBACK(xa) cost -1000
{
    var op := PushStackOp($$, 2);
    E_sta();
    E_stackref(op.stk.sid);
    E_nl();

    E_stx();
    E_stackref(op.stk.sid+1);
    E_nl();
}

gen xa := FALLBACK(a16) uses y cost -1000
{
    var op := PopOp();
    DoParamDirect_lda(op, 0);
    DoParamDirect(op, OC_LDX, 1);
}

gen xa := DEREF2(ADDRESS():a)
{
    var cache := RegCacheFindValue(&$a.sym, $a.off);
    if cache != REG_XA then
        E_lda();
        E_symref(&$a.sym, $a.off);
        E_nl();

        E_ldx();
        E_symref(&$a.sym, $a.off+1);
        E_nl();
    end if;
    RegCacheLeavesValue(REG_XA, &$a.sym, $a.off);
}

gen xa := DEREF2(ptrs)
{
    var ptr := PopAndDerefOp();

    DoParamDirect_lda(ptr, 1);
    E_tax();
    DoParamDirect_lda(ptr, 0);
}

gen xa := CONSTANT():c
{
    E_loadconst(REG_A, $c.value as uint8);
    E_loadconst(REG_X, ($c.value>>8) as uint8);
}

gen xa := ADDRESS():a
{
    E_loadaddr(&$a.sym, $a.off);
}

gen xa := SUBREF():a
{
    E_loadsubref($a.subr);
}

gen STORE2(xa, DEREF2(ADDRESS():a))
{
    E_sta();
    E_symref(&$a.sym, $a.off);
    E_nl();

    E_stx();
    E_symref(&$a.sym, $a.off+1);
    E_nl();
    RegCacheLeavesValue(REG_XA, &$a.sym, $a.off);
}

gen STORE2(xa, DEREF2(ptrs)) uses y
{
    var op := PopAndDerefOp();

    DoParamDirect_sta(op, 0);
    E_txa();
    DoParamDirect_sta(op, 1);
}

%{
    sub DoXA(oc: uint8) is
        var rhs := PopOp();

        R_flush(REG_A|REG_X|REG_XA);
        DoParamDirect(rhs, oc, 0);
        E_pha();
        E_txa();
        DoParamDirect(rhs, oc, 1);
        E_tax();
        E_pla();
    end sub;

    sub DoXADest(oc: uint8) is
        var dest := PopAndDerefOp();
        var rhs := PopOp();

        R_flush(REG_A|REG_X|REG_XA);
        DoParamDirect(rhs, oc, 0);
        DoParamDirect(dest, OC_STA, 0);
        E_txa();
        DoParamDirect(rhs, oc, 1);
        DoParamDirect(dest, OC_STA, 1);
    end sub;

    sub DoXA_neg() is
        var rhs := PopOp();

        R_flush(REG_A|REG_X|REG_XA);

        E_sec();
        E_loadconst(REG_A, 0);
        DoParamDirect(rhs, OC_SBC, 0);
        E_pha();
        E_txa();
        E_loadconst(REG_A, 0);
        DoParamDirect(rhs, OC_SBC, 1);
        E_tax();
        E_pla();
    end sub;

    sub DoXA_not() is
        var rhs := PopOp();

        R_flush(REG_A|REG_X|REG_XA);

        DoParamDirect_lda(rhs, 0);
        E_not();
        E_pha();
        DoParamDirect_lda(rhs, 1);
        E_not();
        E_tax();
        E_pla();
    end sub;
%}

gen xa := NEG2(in2s)         uses y { DoXA_neg(); }
gen xa := NOT2(in2s)         uses y { DoXA_not(); }

gen xa := ADD2(in2s, xa) uses y { E_clc(); DoXA(OC_ADC); }
gen xa := SUB2(xa, in2s) uses y { E_sec(); DoXA(OC_SBC); }
gen xa := AND2(in2s, xa) uses y {          DoXA(OC_AND); }
gen xa := OR2 (in2s, xa) uses y {          DoXA(OC_ORA); }
gen xa := EOR2(in2s, xa) uses y {          DoXA(OC_EOR); }

gen xa := LSHIFT2(xa, y) { E_callhelper("_lshift2"); }
gen xa := RSHIFTU2(xa, y) { E_callhelper("_rshiftu2"); }
gen xa := RSHIFTS2(xa, y) { E_callhelper("_rshifts2"); }

%{
    sub MulOrDiv2(name: string) is
        var e := GetHelper("_mathpad");

        var subid := e.id;

        E_sta();
        E_wsref(subid, PTRMEM_WS, 0);
        E_nl();

        E_stx();
        E_wsref(subid, PTRMEM_WS, 1);
        E_nl();

        var rhs := PopOp();
        DoParamDirect_lda(rhs, 0);
        DoParamDirect(rhs, OC_LDX, 1);
        E_callhelper(name);
    end sub;

    sub Rem2(name: string) is
        MulOrDiv2(name);

        var e := GetHelper("_mathpad");

        var subid := e.id;

        E_lda();
        E_wsref(subid, PTRMEM_WS, 4);
        E_nl();

        E_ldx();
        E_wsref(subid, PTRMEM_WS, 5);
        E_nl();
    end sub;
%}

gen xa := MUL2(xa, in2s) uses y { MulOrDiv2("_mul2"); }
gen xa := DIVU2(xa, in2s) uses y { MulOrDiv2("_divu2r"); }
gen xa := DIVS2(xa, in2s) uses y { MulOrDiv2("_divs2r"); }
gen xa := REMU2(xa, in2s) uses y { Rem2("_divu2r"); }
gen xa := REMS2(xa, in2s) uses y { Rem2("_divs2r"); }

// --- 32 bit ---------------------------------------------------------------

%{
    sub DoCopy4(dest: [MOperand], lhs: [MOperand]) is
        E_loadconst(REG_Y, 3);
        var lid := E_new_label();

        DoParamIndirect_lda(lhs);
        DoParamIndirect_sta(dest);

        E_dey();
        E_bpl(lid);
    end sub;
%}

gen STORE4(in4s, DEREF4(ptrs)) uses a|x|y
{
    var dest := PopAndDerefOp();
    var lhs := PopOp();
    DoCopy4(dest, lhs);
}

gen v32 := DEREF4(ptrs) uses a|x|y
{
    var lhs := PopAndDerefOp();
    var dest := PushV32();
    DoCopy4(dest, lhs);
}

%{
    sub Do2Op4_not(lhs: [MOperand], dest: [MOperand]) is
        E_loadconst(REG_Y, 3);
        var lid := E_new_label();

        DoParamIndirect_lda(lhs);
        E_not();
        DoParamIndirect_sta(dest);

        E_dey();
        E_bpl(lid);
    end sub;

    sub Do2Op4_neg(lhs: [MOperand], dest: [MOperand]) is
        E_loadconst(REG_X, 4);
        E_loadconst(REG_Y, 0);
        E_sec();
        var lid := E_new_label();

        E_loadconst(REG_A, 0);
        DoParamIndirect_sbc(lhs);
        DoParamIndirect_sta(dest);

        E_iny();
        E_dex();
        E_bne(lid);
    end sub;
%}

gen v32 := NEG4(in4s) uses a|x|y { var lhs := PopOp(); var dest := PushV32(); Do2Op4_neg(lhs, dest); }
gen v32 := NOT4(in4s) uses a|x|y { var lhs := PopOp(); var dest := PushV32(); Do2Op4_not(lhs, dest); }
gen STORE4(NEG4(in4s), DEREF4(ptrs)) uses a|x|y { var dest := PopAndDerefOp(); var lhs := PopOp(); Do2Op4_neg(lhs, dest); }
gen STORE4(NOT4(in4s), DEREF4(ptrs)) uses a|x|y { var dest := PopAndDerefOp(); var lhs := PopOp(); Do2Op4_not(lhs, dest); }

%{
    sub Do3Op4(oc: uint8, lhs: [MOperand], rhs: [MOperand], dest: [MOperand]) is
        var lid: LabelRef;
        if (lhs.mode > MODE_STACKI) and (rhs.mode > MODE_STACKI) and (dest.mode > MODE_STACKI) then
            # None of the operands are indirected, so we can use a more efficient loop.

            E_loadconst(REG_Y, 252);
            lid := E_new_label();

            DoParamIndirect(lhs, OC_LDA, -252);
            DoParamIndirect(rhs, oc, -252);
            DoParamIndirect(dest, OC_STA, -252);

            E_iny();
            E_bne(lid);
        else
            E_loadconst(REG_Y, 0);
            E_loadconst(REG_X, 4);
            lid := E_new_label();

            DoParamIndirect_lda(lhs);
            DoParamIndirect(rhs, oc, 0);
            DoParamIndirect_sta(dest);

            E_iny();
            E_dex();
            E_bne(lid);
        end if;
    end sub;
%}

gen v32 := ADD4(in4s, in4s) uses a|x|y { var rhs := PopOp(); var lhs := PopOp(); var dest := PushV32(); E_clc(); Do3Op4(OC_ADC, lhs, rhs, dest); }
gen v32 := SUB4(in4s, in4s) uses a|x|y { var rhs := PopOp(); var lhs := PopOp(); var dest := PushV32(); E_sec(); Do3Op4(OC_SBC, lhs, rhs, dest); }
gen v32 := AND4(in4s, in4s) uses a|x|y { var rhs := PopOp(); var lhs := PopOp(); var dest := PushV32();          Do3Op4(OC_AND, lhs, rhs, dest); }
gen v32 := OR4(in4s, in4s)  uses a|x|y { var rhs := PopOp(); var lhs := PopOp(); var dest := PushV32();          Do3Op4(OC_ORA, lhs, rhs, dest); }
gen v32 := EOR4(in4s, in4s) uses a|x|y { var rhs := PopOp(); var lhs := PopOp(); var dest := PushV32();          Do3Op4(OC_EOR, lhs, rhs, dest); }
gen STORE4(ADD4(in4s, in4s), DEREF4(ptrs)) uses a|x|y { var dest := PopAndDerefOp(); var rhs := PopOp(); var lhs := PopOp(); E_clc(); Do3Op4(OC_ADC, lhs, rhs, dest); }
gen STORE4(SUB4(in4s, in4s), DEREF4(ptrs)) uses a|x|y { var dest := PopAndDerefOp(); var rhs := PopOp(); var lhs := PopOp(); E_sec(); Do3Op4(OC_SBC, lhs, rhs, dest); }
gen STORE4(AND4(in4s, in4s), DEREF4(ptrs)) uses a|x|y { var dest := PopAndDerefOp(); var rhs := PopOp(); var lhs := PopOp();          Do3Op4(OC_AND, lhs, rhs, dest); }
gen STORE4(OR4(in4s, in4s) , DEREF4(ptrs)) uses a|x|y { var dest := PopAndDerefOp(); var rhs := PopOp(); var lhs := PopOp();          Do3Op4(OC_ORA, lhs, rhs, dest); }
gen STORE4(EOR4(in4s, in4s), DEREF4(ptrs)) uses a|x|y { var dest := PopAndDerefOp(); var rhs := PopOp(); var lhs := PopOp();          Do3Op4(OC_EOR, lhs, rhs, dest); }

%{
    sub MulOrDivOrRem4(name: string, resultoffset: uint8, lhs: [MOperand], rhs: [MOperand], dest: [MOperand]) is
        var e := GetHelper("_mathpad");

        E_loadconst(REG_Y, 3);
        var lid := E_new_label();

        var subid := e.id;
        sub ldst(oc: uint8, off: Size) is
            E_oc(oc);
            E_wsref(subid, PTRMEM_WS, off);
            E_y_nl();
        end sub;

        DoParamIndirect_lda(lhs);
        ldst(OC_STA, 0);

        DoParamIndirect_lda(rhs);
        ldst(OC_STA, 8);

        E_dey();
        E_bpl(lid);

        E_callhelper(name);

        E_loadconst(REG_Y, 3);
        lid := E_new_label();

        ldst(OC_LDA, resultoffset as uint16);
        DoParamIndirect_sta(dest);

        E_dey();
        E_bpl(lid);
    end sub;

    sub MulOrDivOrRem4ToV32(name: string, resultoffset: uint8) is
        var rhs := PopOp();
        var lhs := PopOp();
        var dest := PushV32();
        MulOrDivOrRem4(name, resultoffset, lhs, rhs, dest);
    end sub;

    sub MulOrDivOrRem4ToDest(name: string, resultoffset: uint8) is
        var dest := PopAndDerefOp();
        var rhs := PopOp();
        var lhs := PopOp();
        MulOrDivOrRem4(name, resultoffset, lhs, rhs, dest);
    end sub;
%}

gen v32 := MUL4(in4s, in4s)  uses a|x|y { MulOrDivOrRem4ToV32("_mul4", 0); }
gen v32 := DIVU4(in4s, in4s) uses a|x|y { MulOrDivOrRem4ToV32("_divu4", 0); }
gen v32 := REMU4(in4s, in4s) uses a|x|y { MulOrDivOrRem4ToV32("_divu4", 4); }
gen v32 := DIVS4(in4s, in4s) uses a|x|y { MulOrDivOrRem4ToV32("_divs4", 0); }
gen v32 := REMS4(in4s, in4s) uses a|x|y { MulOrDivOrRem4ToV32("_divs4", 4); }
gen STORE4(MUL4(in4s, in4s),  DEREF4(ptrs)) uses a|x|y { MulOrDivOrRem4ToDest("_mul4", 0); }
gen STORE4(DIVU4(in4s, in4s), DEREF4(ptrs)) uses a|x|y { MulOrDivOrRem4ToDest("_divu4", 0); }
gen STORE4(REMU4(in4s, in4s), DEREF4(ptrs)) uses a|x|y { MulOrDivOrRem4ToDest("_divu4", 4); }
gen STORE4(DIVS4(in4s, in4s), DEREF4(ptrs)) uses a|x|y { MulOrDivOrRem4ToDest("_divs4", 0); }
gen STORE4(REMS4(in4s, in4s), DEREF4(ptrs)) uses a|x|y { MulOrDivOrRem4ToDest("_divs4", 4); }

%{
    sub Shift4(helper: string) is
        var lhs := PopOp();
        var dest := PushV32();
        E_loadstackref(lhs.stk.sid);
        E_callhelper(helper);
    end sub;
%}

gen v32 := LSHIFT4(v32, y) { Shift4("_lshift4"); }
gen v32 := RSHIFTU4(v32, y) { Shift4("_rshiftu4"); }
gen v32 := RSHIFTS4(v32, y) { Shift4("_rshifts4"); }

// --- Conditionals ---------------------------------------------------------

gen BEQ0(CONSTANT():lhs, CONSTANT():rhs):b uses all
{
    var label := $b.falselabel;
    if $lhs.value == $rhs.value then
        label := $b.truelabel;
    end if;
    if label != $b.fallthrough then
        E_jmp(label);
    end if;
}

gen BEQ1(a:lhs, in1s:rhs):b uses all
{
    var rhs := PopOp();
    DoParamDirect(rhs, OC_CMP, 0);
    E_jumps_beq_bne(self.n[0]);
}

gen BLTU1(a:lhs, in1s:rhs):b uses all
{
    var rhs := PopOp();
    DoParamDirect(rhs, OC_CMP, 0);
    E_jumps_bcc_bcs(self.n[0]);
}

gen BLTS1(a:lhs, in1s:rhs):b uses all
{
    var rhs := PopOp();
    E_sec();
    DoParamDirect(rhs, OC_SBC, 0);
    E("\tbvc *+4\n");
    E("\teor #$80\n");
    E_jumps_bmi_bpl(self.n[0]);
}

gen BEQ2(xa:lhs, in2s:rhs):b uses all
{
    var rhs := PopOp();
    DoParamDirect(rhs, OC_CMP, 0);
    E_bne($b.falselabel);

    var oc: uint8 := OC_CPX;
    $ifndef TINY
        if ($rhs & REGCLASS_DEREFS) != 0 then
            E_txa();
            oc := OC_CMP;
        end if;
    $endif
    DoParamDirect(rhs, oc, 1);
    E_jumps_beq_bne(self.n[0]);
}

gen BLTU2(xa:lhs, in2s:rhs):c uses all
{
    var rhs := PopOp();
    E_sec();
    DoParamDirect(rhs, OC_SBC, 0);

    E_txa();
    DoParamDirect(rhs, OC_SBC, 1);
    E_jumps_bcc_bcs(self.n[0]);
}

gen BLTS2(xa:lhs, in2s:rhs):c
{
    var rhs := PopOp();
    E_sec();
    DoParamDirect(rhs, OC_SBC, 0);

    E_txa();
    DoParamDirect(rhs, OC_SBC, 1);
    E("\tbvc *+4\n");
    E("\teor #$80\n");
    E_jumps_bmi_bpl(self.n[0]);
}

%{
    sub DoCmp4EQ(node: [Node]) is
        var rhs := PopOp();
        var lhs := PopOp();

        E_loadconst(REG_Y, 3);
        var lid := E_new_label();

        DoParamIndirect_lda(lhs);
        DoParamIndirect(rhs, OC_CMP, 0);
        E_bne(node.beq.falselabel);

        E_dey();
        E_bpl(lid);

        if node.beq.fallthrough != node.beq.truelabel then
            E_jmp(node.beq.truelabel);
        end if;
    end sub;

    sub DoCmp4LT(node: [Node], sext: uint8) is
        var rhs := PopOp();
        var lhs := PopOp();
        var lid: uint16;

        $ifndef TINY
        if (lhs.mode > MODE_STACKI) and (rhs.mode > MODE_STACKI) then
            E_loadconst(REG_Y, 252);
            E_sec();
            lid := E_new_label();

            DoParamIndirect(lhs, OC_LDA, -252);
            DoParamIndirect(rhs, OC_SBC, -252);

            E_iny();
            E_bne(lid);
        else
        $endif
            E_loadconst(REG_X, 4);
            E_loadconst(REG_Y, 0);
            E_sec();
            lid := E_new_label();

            DoParamIndirect_lda(lhs);
            DoParamIndirect_sbc(rhs);

            E_iny();
            E_dex();
            E_bne(lid);
        $ifndef TINY
        end if;
        $endif

        if sext != 0 then
            E_tay(); # set flags from A
            E("\tbvc *+4\n");
            E("\teor #$80\n");
            E_jumps_bmi_bpl(node);
        else
            E_jumps_bcc_bcs(node);
        end if;
    end sub;
%}

gen BEQ4(in4s, in4s):b uses all { DoCmp4EQ(self.n[0]); }
gen BLTU4(in4s, in4s):b uses all { DoCmp4LT(self.n[0], 0); }
gen BLTS4(in4s, in4s):b uses all { DoCmp4LT(self.n[0], 1); }

// --- Casts ----------------------------------------------------------------

gen xa := CAST12(a):c uses y
{
    E_loadconst(REG_X, 0);
    if $c.sext != 0 then
        E_tay(); # cheap way to set flags based on A
        E("\tbpl *+3\n");
        E_dex();
    end if;
}

%{
    sub Cast14(dest: [MOperand], sext: uint8) is
        DoParamDirect_sta(dest, 0);

        if sext != 0 then
            E_callhelper("_signa");
        else
            E_loadconst(REG_A, 0);
        end if;

        DoParamDirect_sta(dest, 1);
        DoParamDirect_sta(dest, 2);
        DoParamDirect_sta(dest, 3);
    end sub;
%}

gen v32 := CAST14(a):c               uses y { var dest := PushV32();       Cast14(dest, $c.sext); }
gen STORE4(CAST14(a):c, DEREF4(ptrs)) uses y { var dest := PopAndDerefOp(); Cast14(dest, $c.sext); }

%{
    sub Cast24(dest: [MOperand], sext: uint8) is
        DoParamDirect_sta(dest, 0);
        if dest.mode <= MODE_STACKI then
            E_txa();
            DoParamDirect_sta(dest, 1);
        else
            DoParamDirect(dest, OC_STX, 1);
        end if;

        if sext != 0 then
            E_txa();
            E_callhelper("_signa");
        else
            E_loadconst(REG_A, 0);
        end if;

        DoParamDirect_sta(dest, 2);
        DoParamDirect_sta(dest, 3);
    end sub;
%}

gen v32 := CAST24(xa):c               uses y { var dest := PushV32();       Cast24(dest, $c.sext); }
gen STORE4(CAST24(xa):c, DEREF4(ptrs)) uses y { var dest := PopAndDerefOp(); Cast24(dest, $c.sext); }

gen a := CAST21(in2s|xa:rhs)
{
    if $rhs != REG_XA then
        var op := PopOp();
        DoParamDirect_lda(op, 0);
    end if;
}

gen a := CAST41(in4s)
{
    var op := PopOp();
    DoParamDirect_lda(op, 0);
}

gen xa := CAST42(in4s)
{
    var op := PopOp();
    DoParamDirect_lda(op, 1);
    E_tax();
    DoParamDirect_lda(op, 0);
}

// --- Case -----------------------------------------------------------------

gen STARTCASE1(a) uses all;
gen STARTCASE2(xa) uses all;

gen STARTCASE4(v32) uses all
{
    var e := GetHelper("_when4");
    var op := PopOp();
    var sid := op.stk.sid;

    E_lda();
    E_constop();
    E_stackref(sid);
    E_lobyte();

    var subid := e.id;

    E_sta();
    E_wsref(subid, PTRMEM_WS, 0);
    E_nl();
    
    E_lda();
    E_constop();
    E_stackref(sid);
    E_hibyte();

    E_sta();
    E_wsref(subid, PTRMEM_WS, 1);
    E_nl();
    
}

gen WHENCASE1():c uses all
{
    E_cmp();
    E_const();
    E_u8($c.value as uint8);
    E_nl();
    E_bne($c.falselabel);
}

gen WHENCASE2():c uses all
{
    E_cmp();
    E_const();
    E_u8($c.value as uint8);
    E_nl();
    E_bne($c.falselabel);

    E_cpx();
    E_const();
    E_u8(($c.value>>8) as uint8);
    E_nl();
    E_bne($c.falselabel);
}

gen WHENCASE4():c uses all
{
    E_callhelper("_when4");
    E_dl();
    E_u32($c.value as uint32);
    E_nl();

    E_bne($c.falselabel);
}

gen ENDCASE1();
gen ENDCASE2();
gen ENDCASE4();

// --- Strings --------------------------------------------------------------

gen xa := STRING():s
{
    R_flush($$);
    var sid := E_string($s.text);

    E_lda();
    E_constop();
    E_labelref(sid);
    E_lobyte();

    E_ldx();
    E_constop();
    E_labelref(sid);
    E_hibyte();
}

// --- Initialisers ---------------------------------------------------------

gen STARTINIT():s
{
    EmitterOpenStream(current_subr);
    E_symref(&$s.sym, 0);
    E(":\n");
}

gen ENDINIT()
{
    EmitterCloseStream();
}

gen INIT1():c
{
    E_db();
    E_u8($c.value as uint8);
    E_nl();
}

gen INIT2():c
{
    E_dw();
    E_u16($c.value as uint16);
    E_nl();
}

gen INIT4():c
{
    E_dl();
    E_u32($c.value as uint32);
    E_nl();
}

gen INITADDRESS():a
{
    E_dw();
    E_symref(&$a.sym, $a.off);
    E_nl();
}

gen INITSUBREF():a
{
    E_dw();
    E_subref($a.subr);
    E_nl();
}

gen INITSTRING():s
{
    var sid := E_string($s.text);

    E_dw();
    E_labelref(sid);
    E_nl();
}

// --- Inline assembly ------------------------------------------------------

gen ASMGROUPSTART() uses all;
gen ASMGROUPEND();

gen ASMSTART()
{
    R_flushall();
    E_tab();
    inasm := 1;
}

gen ASMTEXT():t
{
    E($t.text);
    E_space();
}

gen ASMSYMBOL():s
{
    E_symref(&$s.sym, 0);
    E_space();
}

gen ASMSUBREF():s
{
    E_subref($s.subr);
    E_space();
}

gen ASMVALUE():c
{
    E_openp();
    E_i32($c.value);
    E_closep();
}

gen ASMEND()
{
    E_nl();
    inasm := 0;
}

// ==========================================================================
//                               OPTIONAL RULES
// ==========================================================================

// These rules make the code better, but aren't actually necessary. They can
// be turned off to try and make a self-hosting compiler.

$ifndef TINY

// --- 65C02 features -------------------------------------------------------

$ifdef ARCH_65C02
    // The 65C02 can store zero to a memory location without needing to use
    // a register. It's kinda limited when it comes to addressing modes.

    gen STORE1(CONSTANT(value==0), DEREF1(ADDRESS():a))
    {
        E_stz();
        E_symref(&$a.sym, $a.off);
        E_nl();
    }

    gen STORE1(CONSTANT(value==0), DEREF1(ADD2(ADDRESS():a, CAST12(x, sext==0))))
    {
        E_stz();
        E_symref(&$a.sym, $a.off);
        E_x_nl();
    }

    gen STORE2(CONSTANT(value==0), DEREF2(ADDRESS():a))
    {
        E_stz();
        E_symref(&$a.sym, $a.off);
        E_nl();

        E_stz();
        E_symref(&$a.sym, $a.off+1);
        E_nl();
    }

    // It can also directly increment and decrement the accumulator.

    %{
        sub SmallAdditionOrSubtraction(oc: uint8, amount: uint8) is
            R_flush(REG_A);
            while amount != 0 loop
                E_oc(oc);
                E_a();
                E_nl();
                amount := amount - 1;
            end loop;
        end sub;
    %}

    gen a := ADD1(a, CONSTANT(value>=0, value<=3):c)
            { SmallAdditionOrSubtraction(OC_INC, $c.value as uint8); }
    gen a := ADD1(a, CONSTANT(value<0, value>=-3):c)
            { SmallAdditionOrSubtraction(OC_DEC, -($c.value as int8) as uint8); }
$endif

// --- Indexed pointers -----------------------------------------------------

// The (zp),y addressing mode gives us a free addition to the pointer when
// dereferencing.

gen STORE1(a, DEREF1(ADD2(ptrs, CONSTANT(value>=0, value<=255):c))) uses y
{
    var dest := PopAndDerefOp();
    E_loadconst(REG_Y, $c.value as uint8);
    DoParamIndirect_sta(dest);
}

gen STORE1(a, DEREF1(ADD2(ADDRESS():a, CAST12(x, sext==0))))
{
    E_sta();
    E_symref(&$a.sym, $a.off);
    E_x_nl();
}

gen STORE1(a, DEREF1(ADD2(ptrs, CAST12(y, sext==0))))
{
    var dest := PopAndDerefOp();
    DoParamIndirect_sta(dest);
}

gen a := DEREF1(ADD2(ptrs, CONSTANT(value>=0, value<=255):c)) uses y
{
    var src := PopAndDerefOp();
    E_loadconst(REG_Y, $c.value as uint8);
    DoParamIndirect_lda(src);
}

gen a := DEREF1(ADD2(ADDRESS():a, CAST12(x, sext==0)))
{
    E_lda();
    E_symref(&$a.sym, $a.off);
    E_x_nl();
}

gen a := DEREF1(ADD2(ptrs, CAST12(y, sext==0)))
{
    var src := PopAndDerefOp();
    DoParamIndirect_lda(src);
}

gen STORE2(xa, DEREF2(ADD2(ptrs, CONSTANT(value>=0, value<=254):c))) uses y
{
    var dest := PopAndDerefOp();

    var off := $c.value as uint8;
    DoParamDirect_sta(dest, off+0);
    E_txa();
    DoParamDirect_sta(dest, off+1);
}

gen xa := DEREF2(ADD2(ptrs, CONSTANT(value>=0, value<=254):c)) uses y
{
    var src := PopAndDerefOp();

    var off := $c.value as uint8;
    DoParamDirect_lda(src, off+1);
    E_tax();
    DoParamDirect_lda(src, off);
}

gen xa := DEREF2(ADD2(ADDRESS():a, CAST12(y, sext==0)))
{
    E_lda();
    E_symref(&$a.sym, $a.off+0);
    E_y_nl();

    E_ldx();
    E_symref(&$a.sym, $a.off+1);
    E_y_nl();
}

gen a := DEREF1(DEREF2(ADDRESS(&sym is zp):a)) uses y
{
    $ifndef ARCH_65C02
        E_loadconst(REG_Y, 0);
    $endif

    E_ld($$);
    E_openp();
    E_symref(&$a.sym, $a.off);
    E(")");
    $ifdef ARCH_65C02
        E_nl();
    $else
        E_y_nl();
    $endif
}

// --- In place increments or decrements ------------------------------------

// Adding or subtracting one to or from a memory location is very common and
// can be optimised.

%{
    sub is_inc_or_dec(value: Arith): (result: uint8) is
        result := 0;
        if (value == 1) or (value == -1) then
            result := 1;
        end if;
    end sub;
%}

gen STORE1(
        ADD1(DEREF1(ADDRESS():a1), CONSTANT(value is inc_or_dec):c),
        DEREF1(ADDRESS():a2)) uses x cost 100
{
    if ($a1.sym.subr == $a2.sym.subr) and ($a1.sym.wsid == $a2.sym.wsid) and ($a1.sym.off == $a2.sym.off)
            and ($a1.off == $a2.off) then
        if $c.value < 0 then
            E_dec();
        else
            E_inc();
        end if;
        E_symref(&$a1.sym, $a1.off);
        E_nl();
    else
        E_ldx();
        E_symref(&$a1.sym, $a1.off);
        E_nl();

        if $c.value < 0 then
            E_dex();
        else
            E_inx();
        end if;

        E_stx();
        E_symref(&$a2.sym, $a2.off);
        E_nl();
    end if;
}

gen STORE2(
        ADD2(DEREF2(ADDRESS():a1), CONSTANT(value is inc_or_dec):c),
        DEREF2(ADDRESS():a2)) uses x|y|a cost 100
{
    var lid := AllocPLabel();
    if ($a1.sym.subr == $a2.sym.subr) and ($a1.sym.wsid == $a2.sym.wsid) and ($a1.sym.off == $a2.sym.off)
            and ($a1.off == $a2.off) then
        if $c.value < 0 then
            E_lda();
            E_symref(&$a1.sym, $a1.off);
            E_nl();

            E_bne(lid);

            E_dec();
            E_symref(&$a1.sym, $a1.off+1);
            E_nl();

            E_label(lid);
            
            E_dec();
            E_symref(&$a1.sym, $a1.off);
            E_nl();
        else
            E_inc();
            E_symref(&$a1.sym, $a1.off);
            E_nl();

            E_bne(lid);

            E_inc();
            E_symref(&$a1.sym, $a1.off+1);
            E_nl();

            E_label(lid);
        end if;
    else
        $ifdef ARCH_65C02
            const LOWREG := REG_A;
        $else
            const LOWREG := REG_Y;
        $endif

        var cache := RegCacheFindValue(&$a1.sym, $a1.off);
        if cache != REG_XA then
            E_ldx();
            E_symref(&$a1.sym, $a1.off+1);
            E_nl();

            E_ld(LOWREG);
            E_symref(&$a1.sym, $a1.off);
            E_nl();
        else
            $ifdef ARCH_65C02
                # Highreg is already in A, where we want it.
            $else
                E_tay();
            $endif
        end if;

        if $c.value < 0 then
            E_bne(lid);
            E_dex();
            E_label(lid);
            E_decrement(LOWREG);
        else
            E_increment(LOWREG);
            E_bne(lid);
            E_inx();
            E_label(lid);
        end if;

        E_stx();
        E_symref(&$a2.sym, $a2.off+1);
        E_nl();

        E_st(LOWREG);
        E_symref(&$a2.sym, $a2.off);
        E_nl();

        $ifdef ARCH_65C02
            RegCacheLeavesValue(REG_XA, &$a2.sym, $a2.off);
        $endif
    end if;
}

// --- Comparisons against zero ---------------------------------------------

gen BEQ1(a:lhs, CONSTANT(value==0)):b uses a|x
{
    E_tax();
    E_jumps_beq_bne(self.n[0]);
}

gen BLTS1(a, CONSTANT(value==0)):b uses x
{
    E_tax();
    E_jumps_beq_bne(self.n[0]);
}

gen BEQ2(xa, CONSTANT(value==0)):b uses a|y
{
    E_tay();
    E_bne($b.falselabel);
    E_txa();
    E_jumps_beq_bne(self.n[0]);
}

gen BEQ2(DEREF2(ADDRESS():a), CONSTANT(value==0)):b uses a
{
    E_lda();
    E_symref(&$a.sym, $a.off);
    E_nl();

    E_bne($b.falselabel);

    E_lda();
    E_symref(&$a.sym, $a.off+1);
    E_nl();

    E_jumps_beq_bne(self.n[0]);
}

gen BLTS2(xa, CONSTANT(value==0)):b
{
    E_txa();
    E_jumps_bmi_bpl(self.n[0]);
}

gen BEQ4(in4s, CONSTANT(value==0)):b uses a|x|y
{
    var lhs := PopOp();

    E_loadconst(REG_Y, 3);
    var lid := E_new_label();

    DoParamIndirect_lda(lhs);
    E_bne($b.falselabel);

    E_dey();
    E_bpl(lid);

    if $b.fallthrough != $b.truelabel then
        E_jmp($b.truelabel);
    end if;
}

gen BLTS4(in4s, CONSTANT(value==0)):b uses a|x|y
{
    var lhs := PopOp();

    DoParamDirect_lda(lhs, 3);
    E_jumps_bmi_bpl(self.n[0]);
}

%{
    sub Shift1(oc: uint8, amount: uint8) is
        while amount != 0 loop
            E_ocnl(oc);
            amount := amount - 1;
        end loop;
    end sub;
%}

// --- Combined casts -------------------------------------------------------

gen a := CAST41(RSHIFTU4(in4s, CONSTANT(value==8))) uses y
{
    var op := PopOp();
    DoParamDirect_lda(op, 1);
}

gen a := CAST41(RSHIFTU4(in4s, CONSTANT(value==16))) uses y
{
    var op := PopOp();
    DoParamDirect_lda(op, 2);
}

gen a := CAST41(RSHIFTU4(in4s, CONSTANT(value==24))) uses y
{
    var op := PopOp();
    DoParamDirect_lda(op, 3);
}

// --- Inline shifts --------------------------------------------------------

gen a := LSHIFT1(a, CONSTANT(value<=3):c) { Shift1(OC_ASL, $c.value as uint8); }
gen a := RSHIFTU1(a, CONSTANT(value<=3):c) { Shift1(OC_LSR, $c.value as uint8); }

gen a := RSHIFTS1(a, CONSTANT(value==1))
{
    E("\tcmp #$80\n");
    E("\tror\n");
}

gen xa := LSHIFT2(CAST12(a, sext==0), CONSTANT(value==1))
{
    E_loadconst(REG_X, 0);
    E("\tasl\n");
    E("\tbcc *+3\n");
    E("\tinx\n");
}

gen xa := RSHIFTU2(xa, CONSTANT(value==8))
{
    E_txa();
    E_loadconst(REG_X, 0);
}

gen a := CAST21(RSHIFTU2(xa, CONSTANT(value==8))) { E_txa(); }
gen a := CAST21(RSHIFTS2(xa, CONSTANT(value==8))) { E_txa(); }

$endif

// vim: sw=4 ts=4 et

