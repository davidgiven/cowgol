# vim: ts=4 sw=4 noet

record CpmFCB is
	dr: uint8;
	f: uint8[11];
	ex: uint8;
	s1: uint8;
	s2: uint8;
	rc: uint8;
	d: uint32[4];   # aligns also CpmFCB to even address
	cr: uint8;
	r: uint8[3];
end record;

record FCB is
	bufferptr: uint8; # byte just read
	dirty: uint8;
	cpm: CpmFCB;
	buffer: uint8[128];
end record;

sub fcb_set_record(fcb: [FCB], recordno: uint32) is
	recordno := recordno & 0x3ffff;
	fcb.cpm.r[0] := ((recordno >> 16) & 0x3) as uint8;
	fcb.cpm.r[1] := ((recordno >> 8) & 0xff) as uint8;
	fcb.cpm.r[2] := (recordno & 0xff) as uint8;
end sub;

sub fcb_get_record(fcb: [FCB]): (recordno: uint32) is
	var r0 := (fcb.cpm.r[0] as uint32) << 16;
	var r1 := (fcb.cpm.r[1] as uint32) << 8;
	var r2 := fcb.cpm.r[2] as uint32;
	recordno := (r0 + r1 + r2) & 0x3ffff;
end sub;

sub file_i_init(fcb: [FCB], filename: [uint8]) is
	sub fill(dest: [uint8], src: [uint8], len: uint8): (srcout: [uint8]) is
		loop
			var c := [src];
			if (c < 32) or (c == '.') then
				c := ' ';
			elseif (c == '*') then
				c := '?';
			else
				src := src + 1;
			end if;
			if (c >= 'a') and (c <= 'z') then
				c := c - ('a' - 'A');
			end if;
			[dest] := c;
			dest := dest + 1;

			len := len - 1;
			if len == 0 then
				break;
			end if;
		end loop;
		srcout := src;
	end sub;

	MemSet(fcb as [uint8], 0, @bytesof FCB);
	MemSet(&fcb.cpm.f[0] as [uint8], ' ', 11);
	filename := fill(&fcb.cpm.f[0], filename, 8);

	var c: uint8;
	loop
		c := [filename];
		if (c < 32) or (c == '.') then
			break;
		end if;
		filename := filename + 1;
	end loop;

	if c == '.' then
		filename := fill(&fcb.cpm.f[8], filename+1, 3);
	end if;

	fcb_set_record(fcb, 0x3ffff);
	fcb.bufferptr := 127;
end sub;

sub fcb_i_gbpb(fcb: [FCB], c: uint16) is
	var cpmfcb := &fcb.cpm;
	var dma := &fcb.buffer[0];

	@asm "move.w #26, %d0";	# BDOS set dma
	@asm "move.l (", dma, "), %d1";
	@asm "trap #2";

	@asm "move.w (", c, "), %d0"; # BDOS call defined in c
	@asm "move.l (", cpmfcb, "), %d1";
	@asm "trap #2";
end sub;

sub fcb_i_blockin(fcb: [FCB]) is
	MemSet(&fcb.buffer[0], 0, 128);
	fcb_i_gbpb(fcb, 33); # READ RANDOM
	fcb.dirty := 0;
end sub;

sub fcb_i_blockout(fcb: [FCB]) is
	if fcb.dirty != 0 then
		fcb_i_gbpb(fcb, 34); # WRITE RANDOM
		fcb.dirty := 0;
	end if;
end sub;

sub fcb_i_changeblock(fcb: [FCB], newblock: uint32) is
	if newblock != fcb_get_record(fcb) then
		fcb_i_blockout(fcb);
		fcb_set_record(fcb, newblock);
		fcb_i_blockin(fcb);
	end if;
end sub;

sub fcb_convert_return_code_to_error(rc: uint8): (errno: uint8) is
	if rc == 0xff then
		errno := 1;
	else
		errno := 0;
	end if;
end sub;

sub FCBOpenIn(fcb: [FCB], filename: [uint8]): (errno: uint8) is
	file_i_init(fcb, filename);
	var cpmfcb := &fcb.cpm;

	@asm "move.w #15, %d0"; # BDOS open file
	@asm "move.l (", cpmfcb, "), %d1";
	@asm "trap #2";
	@asm "move.b %d0, (", errno, ")";
	errno := fcb_convert_return_code_to_error(errno);
end sub;

sub FCBOpenUp(fcb: [FCB], filename: [uint8]): (errno: uint8) is
	(errno) := FCBOpenIn(fcb, filename);
end sub;

sub FCBOpenOut(fcb: [FCB], filename: [uint8]): (errno: uint8) is
	file_i_init(fcb, filename);
	var cpmfcb := &fcb.cpm;

	@asm "move.w #19, %d0"; # BDOS delete file
	@asm "move.l (", cpmfcb, "), %d1";
	@asm "trap #2";

	@asm "move.w #22, %d0"; # BDOS make file
	@asm "move.l (", cpmfcb, "), %d1";
	@asm "trap #2";
	@asm "move.b %d0, (", errno, ")";
	errno := fcb_convert_return_code_to_error(errno);
end sub;
	
sub FCBClose(fcb: [FCB]): (errno: uint8) is
	fcb_i_blockout(fcb);
	var cpmfcb := &fcb.cpm;

	@asm "move.w #16, %d0"; # BDOS close file
	@asm "move.l (", cpmfcb, "), %d1";
	@asm "trap #2";
	@asm "move.b %d0, (", errno, ")";
	errno := fcb_convert_return_code_to_error(errno);
end sub;

sub FCBSeek(fcb: [FCB], pos: uint32) is
	pos := pos - 1; # seek to *previous* character
	var newblock := (pos >> 7) as uint32;
	var newptr := (pos as uint8) & 127;
	fcb_i_changeblock(fcb, newblock);
	fcb.bufferptr := newptr;
end sub;

sub FCBPos(fcb: [FCB]): (pos: uint32) is
	pos := ((fcb_get_record(fcb)  << 7) | (fcb.bufferptr as uint32)) + 1;
end sub;

sub FCBExt(fcb: [FCB]): (len: uint32) is
	var oldblock := fcb_get_record(fcb);
	var cpmfcb := &fcb.cpm;

	@asm "move.w #16, %d0"; # BDOS close file
	@asm "move.l (", cpmfcb, "), %d1";
	@asm "trap #2";


	@asm "move.w #35, %d0"; # BDOS compute file size
	@asm "move.l (", cpmfcb, "), %d1";
	@asm "trap #2";

	len := fcb_get_record(fcb) << 7;
	fcb_set_record(fcb, oldblock);
end sub;

sub fcb_i_nextchar(fcb: [FCB]) is
	fcb.bufferptr := fcb.bufferptr + 1;
	if fcb.bufferptr == 128 then
		fcb_i_changeblock(fcb, fcb_get_record(fcb) + 1);
		fcb.bufferptr := 0;
	end if;
end sub;

sub FCBGetChar(fcb: [FCB]): (c: uint8) is
	fcb_i_nextchar(fcb);
	c := fcb.buffer[fcb.bufferptr];
end sub;

sub FCBPutChar(fcb: [FCB], c: uint8) is
	fcb_i_nextchar(fcb);
	fcb.buffer[fcb.bufferptr] := c;
	fcb.dirty := 1;
end sub;

include "common-file.coh";

